<!DOCTYPE html><html><head><meta charset="utf-8"><title>最短路算法 | Jamence&#39;s blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="最短路"><meta name="description" content="最短路算法松弛操作 松弛：v-&amp;gt;w的距离可以通过p点来缩短，即dis（v,w）&amp;lt;dis(v,p)+dis(p,w)  Dijkstra算法（单源最短路）维基简介： 戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始"><meta name="keywords" content="最短路"><meta property="og:type" content="article"><meta property="og:title" content="最短路算法"><meta property="og:url" content="http://yoursite.com/2018/02/27/最短路算法/index.html"><meta property="og:site_name" content="Jamence&#39;s blog"><meta property="og:description" content="最短路算法松弛操作 松弛：v-&amp;gt;w的距离可以通过p点来缩短，即dis（v,w）&amp;lt;dis(v,p)+dis(p,w)  Dijkstra算法（单源最短路）维基简介： 戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始"><meta property="og:locale" content="en"><meta property="og:image" content="http://yoursite.com/2018/02/27/最短路算法/index.jpg"><meta property="og:updated_time" content="2018-03-01T07:38:12.145Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="最短路算法"><meta name="twitter:description" content="最短路算法松弛操作 松弛：v-&amp;gt;w的距离可以通过p点来缩短，即dis（v,w）&amp;lt;dis(v,p)+dis(p,w)  Dijkstra算法（单源最短路）维基简介： 戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始"><meta name="twitter:image" content="http://yoursite.com/2018/02/27/最短路算法/index.jpg"><link rel="alternate" href="/atom.xml" title="Jamence&#39;s blog" type="application/atom+xml"><link rel="icon" href="/css/images/favicon.ico"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/libs/titillium-web/styles.css"><link rel="stylesheet" href="/libs/source-code-pro/styles.css"><link rel="stylesheet" href="/css/style.css"><script src="/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css"><link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><script>!function(e,a,n,t,c,g,o){e.GoogleAnalyticsObject=c,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement(n),o=a.getElementsByTagName(n)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document,"script",0,"ga"),ga("create","Jamence","auto"),ga("send","pageview")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?Jamence";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><div id="wrap"><header id="header"><div id="header-outer" class="outer"><div class="container"><div class="container-inner"><div id="header-title"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><h2 class="subtitle-wrap"><p class="subtitle">everything is funny when you are exploring</p></h2></div><div id="header-inner" class="nav-container"><a id="main-nav-toggle" class="nav-icon fa fa-bars"></a><div class="nav-container-inner"><ul id="main-nav"><li class="main-nav-list-item"> <a class="main-nav-list-link" href="/">Home</a></li><ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Languages/">Languages</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Languages/c/">c++</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Lifes/">Lifes</a></li></ul><li class="main-nav-list-item"> <a class="main-nav-list-link" href="/about/index.html">About</a></li></ul><nav id="sub-nav"><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div></nav></div></div></div></div></div></header><div class="container"><div class="main-body container-inner"><div class="main-body-inner"><section id="main"><div class="main-body-header"><h1 class="header"> <a class="page-title-link" href="/categories/Algorithm/">Algorithm</a></h1></div><div class="main-body-content"><article id="post-最短路算法" class="article article-single article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name"> 最短路算法</h1></header><div class="article-meta"><div class="article-date"> <a href="/2018/02/27/最短路算法/" class="article-date"><time datetime="2018-02-27T12:26:01.000Z" itemprop="datePublished">2018-02-27</time></a></div><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/最短路/">最短路</a></div></div><div class="article-entry" itemprop="articleBody"><p><img src="/2018/02/27/最短路算法/index.jpg" alt="uchiha itachi"></p><h1 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h1><h2 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h2><blockquote><p>松弛：v-&gt;w的距离可以通过p点来缩短，即<br><code>dis（v,w）&lt;dis(v,p)+dis(p,w)</code></p></blockquote><h2 id="Dijkstra算法（单源最短路）"><a href="#Dijkstra算法（单源最短路）" class="headerlink" title="Dijkstra算法（单源最短路）"></a>Dijkstra算法（单源最短路）</h2><h3 id="维基简介："><a href="#维基简介：" class="headerlink" title="维基简介："></a>维基简介：</h3><blockquote><p>戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。</p></blockquote><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><blockquote><p>这个算法是通过为每个顶点 v 保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。</p><p>边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。</p></blockquote><p> <strong><em>说人话！！！</em></strong><br>就是我们通过bfs遍历每一个点（通过边），当遍历到u点时，我们已知u点的邻边以及邻边的另一端的顶点v。我们通过u点来更新s到v的距离。<br>代码描述就是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(dis[v]&lt;dis[u]+edge(u,v))&#123;</span><br><span class="line">  dis[v]=dis[u]+edge(u,v);</span><br><span class="line">  //edge(u,v)表示u，v间边的距离。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int to,cost;</span><br><span class="line">    edge(int to,int cost)&#123;</span><br><span class="line">        this-&gt;to=to;</span><br><span class="line">        this-&gt;cost=cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef pair&lt;int,int&gt;point;</span><br><span class="line">int dis[maxn];</span><br><span class="line">vector&lt;edge&gt;Ed[maxn];</span><br><span class="line">void addEdge(int u,int v,int value)&#123;</span><br><span class="line">    Ed[u].push_back(edge(v,value));</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s,int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)dis[i]=INF;</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q;</span><br><span class="line">    q.push(point(dis[s],s));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        point cur=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        int v=cur.second;</span><br><span class="line">        for(int i=0;i&lt;Ed[v].size();i++)&#123;</span><br><span class="line">            edge e=Ed[v][i];</span><br><span class="line">            if(dis[e.to]&gt;dis[v]+e.cost)&#123;</span><br><span class="line">                dis[e.to]=dis[v]+e.cost;</span><br><span class="line">                q.push(point(dis[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spfa算法（单源最短路并且判负环）"><a href="#spfa算法（单源最短路并且判负环）" class="headerlink" title="spfa算法（单源最短路并且判负环）"></a>spfa算法（单源最短路并且判负环）</h2><h3 id="存在的原因"><a href="#存在的原因" class="headerlink" title="存在的原因"></a>存在的原因</h3><p>我们在使用Dijstra算法时，如果出现负环，我们无法得出正确答案。<br>我们来分析一下Dijstra算法的代码实现部分<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;Ed[v].size();i++)&#123;</span><br><span class="line">    edge e=Ed[v][i];</span><br><span class="line">    if(dis[e.to]&gt;dis[v]+e.cost)&#123;</span><br><span class="line">        dis[e.to]=dis[v]+e.cost;</span><br><span class="line">        q.push(point(dis[e.to],e.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们运行一下如下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int to,cost;</span><br><span class="line">    edge(int to,int cost)&#123;</span><br><span class="line">        this-&gt;to=to;</span><br><span class="line">        this-&gt;cost=cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef pair&lt;int,int&gt;point;</span><br><span class="line">int dis[maxn];</span><br><span class="line">vector&lt;edge&gt;Ed[maxn];</span><br><span class="line">void addEdge(int u,int v,int value)&#123;</span><br><span class="line">    Ed[u].push_back(edge(v,value));</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s,int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)dis[i]=INF;</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q;</span><br><span class="line">    q.push(point(dis[s],s));</span><br><span class="line">    cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;s&lt;&lt;&quot;        距离为&quot;&lt;&lt;dis[s]&lt;&lt;endl;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        point cur=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        int v=cur.second;</span><br><span class="line">        for(int i=0;i&lt;Ed[v].size();i++)&#123;</span><br><span class="line">            edge e=Ed[v][i];</span><br><span class="line">            if(dis[e.to]&gt;dis[v]+e.cost)&#123;</span><br><span class="line">                dis[e.to]=dis[v]+e.cost;</span><br><span class="line">                q.push(point(dis[e.to],e.to));</span><br><span class="line">                cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;e.to&lt;&lt;&quot;        距离为&quot;&lt;&lt;dis[e.to]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    addEdge(0,1,2);</span><br><span class="line">    addEdge(1,0,2);</span><br><span class="line">    addEdge(0,2,1);</span><br><span class="line">    addEdge(2,0,1);</span><br><span class="line">    addEdge(1,2,-5);</span><br><span class="line">    addEdge(2,1,-5);</span><br><span class="line">    Dijkstra(0,3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们构造了一个负环，（0，1，2）（无向图）<br>0号节点与1号节点相连，距离为2<br>0号节点与2号节点相连，距离为1<br>1号节点与2号节点相连，距离为-5<br>运行结果如图：<br><img src="/2018/02/27/最短路算法/1.PNG" alt="运行结果"><br>我们知道Dijkstra算法是通过不断更新相邻点的最小距离，由于存在负数，越更新，距离越小（负数越加越小），所以无法得出正确结论，甚至无法跳出循环。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>其实和Dijkstra没有什么区别，只是加了判负环的操作。<br>判负环的操作：<br>我们一共有<code>n</code>个点，如果我们要得到最短路，不会有重复的路径。其次，对于一个点，与其相邻的最多有<code>n-1</code>个，即该点最多可以被更新<code>n-1</code>次。<br>所以，我们只需要记录一个点入栈多少次，如果大于<code>n-1</code>，（或者<code>n</code>）则一定存在负权还。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  时间复杂度O(kE)</span><br><span class="line"> *  队列实现，有时候改成栈实现会更快，较容易修改</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const int MAXN = 1010;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int v;</span><br><span class="line">    int cost;</span><br><span class="line">    Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; E[MAXN];</span><br><span class="line"></span><br><span class="line">void addEdge(int u, int v, int w)</span><br><span class="line">&#123;</span><br><span class="line">    E[u].push_back(Edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool vis[MAXN];     //  在队列标志</span><br><span class="line">int cnt[MAXN];      //  每个点的入列队次数</span><br><span class="line">int dist[MAXN];</span><br><span class="line"></span><br><span class="line">bool SPFA(int start, int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dist, 0x3f, sizeof(dist));</span><br><span class="line"></span><br><span class="line">    vis[start] = true;</span><br><span class="line">    dist[start] = 0;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line"></span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    que.push(start);</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line">    cnt[start] = 1;</span><br><span class="line"></span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = false;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; E[u].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int v = E[u][i].v;</span><br><span class="line">            if (dist[v] &gt; dist[u] + E[u][i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">                if (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                    if (++cnt[v] &gt; n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        return false;   //  cnt[i]为入队列次数，用来判定是否存在负环回路</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd-Warshall算法（多源最短路）"><a href="#Floyd-Warshall算法（多源最短路）" class="headerlink" title="Floyd-Warshall算法（多源最短路）"></a>Floyd-Warshall算法（多源最短路）</h2><h3 id="维基简介"><a href="#维基简介" class="headerlink" title="维基简介"></a>维基简介</h3><blockquote><p>Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。<br>Floyd-Warshall算法的时间复杂度为O(N^3)，空间复杂度为O(N2)。</p></blockquote><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>Floyd-Warshall算法的原理是动态规划<br>我们假设<code>只使用顶点0~k和i，j的情况下，记录i到j的最短路长度为d[k+1][i][j]</code><br>所以d[0][i][j]表示不使用中间节点是i到j的距离，那么直接等于cost[i][j]<br>我们分成两种情况：</p><ul><li>不经过顶点k<br><code>d[k][i][j]=d[k-1][i][j];</code></li><li>经过顶点k<br><code>d[k][i][j]=d[k-1][i][k]+d[k-1][k][j];</code></li></ul><p>所以，我们可以得知<code>d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j])</code>;<br>同时，我们可以去掉一维数组<br><code>d[i][j]=min(d[i][k],d[k][j])</code></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Floyd算法，求从任意节点i到任意节点j的最短路径</span><br><span class="line"> *  cost[][]:初始化为INF（cost[i][i]：初始化为0）</span><br><span class="line"> *  lowcost[][]:最短路径，path[][]:最短路径（无限制）</span><br><span class="line"> */</span><br><span class="line">const int MAXN = 100;</span><br><span class="line"></span><br><span class="line">int cost[MAXN][MAXN];</span><br><span class="line">int lowcost[MAXN][MAXN];</span><br><span class="line">int path[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">void Floyd(int n)</span><br><span class="line">&#123;</span><br><span class="line">    memcpy(lowcost, cost, sizeof(cost));</span><br><span class="line">    memset(path, -1, sizeof(path));</span><br><span class="line"></span><br><span class="line">    for (int k = 0; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (lowcost[i][j] &gt; (lowcost[i][k] + lowcost[k][j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    lowcost[i][j] = lowcost[i][k] + lowcost[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><div class="a2a_kit a2a_default_style"> <a class="a2a_dd" href="https://www.addtoany.com/share">Share</a><span class="a2a_divider"></span><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_google_plus"></a><a class="a2a_button_pinterest"></a><a class="a2a_button_tumblr"></a></div><script src="//static.addtoany.com/menu/page.js"></script><style>.a2a_menu{border-radius:4px}.a2a_menu a{margin:2px 0;font-size:14px;line-height:16px;border-radius:4px;color:inherit!important;font-family:'Microsoft Yahei'}#a2apage_dropdown{margin:10px 0}.a2a_mini_services{padding:10px}a.a2a_i,i.a2a_i{width:122px;line-height:16px}a.a2a_i .a2a_svg,a.a2a_more .a2a_svg{width:16px;height:16px;line-height:16px;vertical-align:top;background-size:16px}a.a2a_i{border:none!important}a.a2a_menu_show_more_less{margin:0;padding:10px 0;line-height:16px}.a2a_mini_services:after{content:".";display:block;height:0;clear:both;visibility:hidden}</style></footer></div></article><div id="lv-container" data-id="city" data-uid="MTAyMC8zNDA0NS8xMDU4Mw=="><script>!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div></div></section><aside id="sidebar"><a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a><div class="sidebar-top"><p>follow:</p><ul class="social-links"><li><a class="social-tooltip" title="github" href="https://github.com/Jamence" target="_blank"><i class="icon fa fa-github"></i></a></li><li><a class="social-tooltip" title="weibo" href="https://weibo.com/p/1005055772753810/home?from=page_100505&mod=TAB#place" target="_blank"><i class="icon fa fa-weibo"></i></a></li><li><a class="social-tooltip" title="rss" href="/atom.xml" target="_blank"><i class="icon fa fa-rss"></i></a></li></ul></div><nav id="article-nav"> <a href="/2018/03/07/并查集/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">newer</strong><p class="article-nav-title"> 并查集</p><i class="icon fa fa-chevron-right" id="icon-chevron-right"></i></a> <a href="/2018/02/26/3月计划/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">older</strong><p class="article-nav-title">3月计划</p><i class="icon fa fa-chevron-left" id="icon-chevron-left"></i></a></nav><div class="widgets-container"><div class="widget-wrap"><h3 class="widget-title">recents</h3><div class="widget"><ul id="recent-post"><li><div class="item-thumbnail"><a href="/2018/03/07/并查集/" class="thumbnail"><span style="background-image:url(/2018/03/07/并查集/index.jpg)" alt="并查集" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p><p class="item-title"><a href="/2018/03/07/并查集/" class="title">并查集</a></p><p class="item-date"><time datetime="2018-03-07T00:06:19.000Z" itemprop="datePublished">2018-03-07</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/02/27/最短路算法/" class="thumbnail"><span style="background-image:url(/2018/02/27/最短路算法/index.jpg)" alt="最短路算法" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p><p class="item-title"><a href="/2018/02/27/最短路算法/" class="title">最短路算法</a></p><p class="item-date"><time datetime="2018-02-27T12:26:01.000Z" itemprop="datePublished">2018-02-27</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/02/26/3月计划/" class="thumbnail"><span style="background-image:url(/2018/02/26/3月计划/index.jpeg)" alt="3月计划" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Lifes/">Lifes</a></p><p class="item-title"><a href="/2018/02/26/3月计划/" class="title">3月计划</a></p><p class="item-date"><time datetime="2018-02-26T15:27:43.000Z" itemprop="datePublished">2018-02-26</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/02/26/c-继承之虚继承/" class="thumbnail"><span style="background-image:url(/2018/02/26/c-继承之虚继承/index.jpg)" alt="c++继承之虚继承" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Languages/">Languages</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Languages/c/">c++</a></p><p class="item-title"><a href="/2018/02/26/c-继承之虚继承/" class="title">c++继承之虚继承</a></p><p class="item-date"><time datetime="2018-02-26T12:43:12.000Z" itemprop="datePublished">2018-02-26</time></p></div></li><li><div class="item-thumbnail"><a href="/2018/02/25/c-继承之多重继承和多继承/" class="thumbnail"><span style="background-image:url(/2018/02/25/c-继承之多重继承和多继承/index.jpg)" alt="c++继承之多重继承和多继承" class="thumbnail-image"></span></a></div><div class="item-inner"><p class="item-category"><a class="article-category-link" href="/categories/Languages/">Languages</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Languages/c/">c++</a></p><p class="item-title"><a href="/2018/02/25/c-继承之多重继承和多继承/" class="title">c++继承之多重继承和多继承</a></p><p class="item-date"><time datetime="2018-02-25T08:18:04.000Z" itemprop="datePublished">2018-02-25</time></p></div></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Languages/">Languages</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Languages/c/">c++</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lifes/">Lifes</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">8</span></li></ul></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">tags</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-继承/">c++继承</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计划/">计划</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap widget-float"><h3 class="widget-title">tag cloud</h3><div class="widget tagcloud"> <a href="/tags/c-继承/" style="font-size:20px">c++继承</a> <a href="/tags/并查集/" style="font-size:10px">并查集</a> <a href="/tags/最短路/" style="font-size:10px">最短路</a> <a href="/tags/计划/" style="font-size:10px">计划</a></div></div><div class="widget-wrap widget-list"><h3 class="widget-title">links</h3><div class="widget"><ul><li> <a href="http://hexo.io">Hexo</a></li><li> <a href="http://blog.csdn.net/Jamence">Jamence</a></li></ul></div></div></div><nav><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=29544830&auto=0&height=66"></iframe></nav></aside></div></div></div><footer id="footer"><div class="container"><div class="container-inner"><a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a><div class="credit"><h1 class="logo-wrap"><a href="/" class="logo"></a></h1><p>&copy; 2018 Jamence</p><p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人次</span></div></div></div></footer><script>var disqus_shortname="Jamence",disqus_url="http://yoursite.com/2018/02/27/最短路算法/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script src="/libs/lightgallery/js/lightgallery.min.js"></script><script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script><script src="/libs/lightgallery/js/lg-pager.min.js"></script><script src="/libs/lightgallery/js/lg-autoplay.min.js"></script><script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script><script src="/libs/lightgallery/js/lg-zoom.min.js"></script><script src="/libs/lightgallery/js/lg-hash.min.js"></script><script src="/libs/lightgallery/js/lg-share.min.js"></script><script src="/libs/lightgallery/js/lg-video.min.js"></script><script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="/js/main.js"></script></div></body></html>