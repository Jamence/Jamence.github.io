{"meta":{"title":"Jamence's blog","subtitle":"everything is funny when you are exploring","description":"Jamence的个人博客","author":"Jamence","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-25T08:11:31.432Z","updated":"2018-02-25T08:11:31.432Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I am nobody with curiosity. Three virtue you should pay attention Laziness The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and document what you wrote so you don’t have to answer so many questions about it. Hence, the first great virtue of a programmer, Also hence, this book. Impatience The anger you feel when the computer is being lazy. This makes you write programs that don’t just react to your needs, but actually anticipate them. Or at least pretend to. Hence, the second great virtue of a programmer. Hubris Excessive pride, the sort of thing Zeus zaps you for. Also the quality that makes you write (and maintain) programs that other people won’t want to say bad things about. Hence, the third great virtue of a programmer. 懒惰：是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。急躁：是这样一种愤怒——当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样。傲慢：极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序。"}],"posts":[{"title":"素数筛法","slug":"素数筛法","date":"2018-03-17T13:17:46.000Z","updated":"2018-03-17T13:33:31.670Z","comments":true,"path":"2018/03/17/素数筛法/","link":"","permalink":"http://yoursite.com/2018/03/17/素数筛法/","excerpt":"","text":"素数 质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。 我们对于素数的判定的确经过了几个过程。我们一个一个来讨论 按照定义我们按照定义来实现找出素数1234567891011int flag=0;if(n&lt;2)flag=1;for(int i=2;i&lt;n;i++)&#123; if(n%i==0)&#123; flag=1; break; &#125;&#125;if(flag)cout&lt;&lt;&quot;不是素数&quot;&lt;&lt;endl;elsecout&lt;&lt;&quot;是素数&quot;&lt;&lt;endl; 通过定义来实现素数的判定。优点是比较好理解，缺点是时间复杂度比较高 埃拉托斯特尼筛法123456789101112memset(vis,0,sizeof(vis)); for(int i=2;i&lt;=n;i++) for(int j=i*2;j&lt;=n;j+=i) vis[j]=1;//优化int m=sqrt(n+0.5);memset(vis,0,sizeof(vis));for(int i=2;i&lt;=m;i++) if(!vis[i]) for(int j=i*i;j&lt;=n;j+=i) vis[j]=1; 这是一种求素数比较方便并且快速的方法。具体思想是筛去2，3，5，7等等的倍数，那么剩余的便是合数。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"素数","slug":"素数","permalink":"http://yoursite.com/tags/素数/"}]},{"title":"大数运算","slug":"大数运算","date":"2018-03-15T13:06:34.000Z","updated":"2018-03-16T15:51:03.109Z","comments":true,"path":"2018/03/15/大数运算/","link":"","permalink":"http://yoursite.com/2018/03/15/大数运算/","excerpt":"","text":"我们知道任何数值都有范围一说，c++肯定也一样int表示32为整数longlong表示64位整数数值过大就会存在溢出的情况怎么办？大数教你做人 大数加123456789101112131415161718192021222324252627282930313233string add(string a,string b)&#123; string c; int len1=a.length(); int len2=b.length(); int len=max(len1,len2); for(int i=len1;i&lt;len;i++) a=&quot;0&quot;+a; for(int i=len2;i&lt;len;i++) b=&quot;0&quot;+b; int ok=0; for(int i=len-1;i&gt;=0;i--) &#123; char temp=a[i]+b[i]-&apos;0&apos;+ok; if(temp&gt;&apos;9&apos;) &#123; ok=1; temp-=10; &#125; else ok=0; c=temp+c; &#125; if(ok) c=&quot;1&quot;+c; int pos=-1; for(int i=0;i&lt;c.length();i++)&#123; if(c[i]==&apos;0&apos;)pos=i; else break; &#125;// cout&lt;&lt;pos&lt;&lt;endl; if(pos==c.length()-1)return &quot;0&quot;; return c.substr(pos+1);&#125; 大数加法只是实现了简单的加减运算，记录每一位相加的结果（总的结果对10取余）以及进位（总的结果除以10） 大数减12345678910111213141516171819202122232425262728293031323334string sub(string a,string b)&#123; string c; bool ok=0; int len1=a.length(); int len2=b.length(); int len=max(len1,len2); for(int i=len1;i&lt;len;i++) a=&quot;0&quot;+a; for(int i=len2;i&lt;len;i++) b=&quot;0&quot;+b; if(a&lt;b) &#123; string temp=a; a=b; b=temp; ok=1; &#125; for(int i=len-1;i&gt;=0;i--) &#123; if(a[i]&lt;b[i]) &#123; a[i-1]-=1; a[i]+=10; &#125; char temp=a[i]-b[i]+&apos;0&apos;; c=temp+c; &#125; int pos=0; while(c[pos]==&apos;0&apos; &amp;&amp; pos&lt;len) pos++; if(pos==len) return &quot;0&quot;; if(ok) return &quot;-&quot;+c.substr(pos); return c.substr(pos);&#125; 大数加法和大数减法类似，如果对应位相减是负数，那么被减数的对应位数字前高一位减1，对应位加10。这是被减数减去减数就是存在的。 大数乘123456789101112131415161718192021string mul(string a,int b)&#123; string c; char s; int len=a.length(); int ok=0; for(int i=len-1;i&gt;=0;i--) &#123; int temp=(a[i]-&apos;0&apos;)*b+ok; ok=temp/10; s=temp%10+&apos;0&apos;; c=s+c; &#125; while(ok) &#123; s=ok%10+&apos;0&apos;; c=s+c; ok/=10; &#125; return c;&#125; 我们假设a*b类似于大数加法运算，a的每一位数字乘上b得到结果的当前位的初始值，当前位初始值对10取模得到结果的当前位。同时进位等于当前位初始值加上进位。我们假设12345*1212345678910 12* 12每一位的初始值等于12 24我们从右向左对十取模并且得到进位，将进位加到高一位的位置。那么有第一步：4（进位为2）第二步：12+2 4第三步：1 4 4结果就是144 大数除123456789101112131415161718string div(string a,int b)&#123; string c; int len=a.length(); int ans=0; char s; for(int i=0;i&lt;len;i++) &#123; ans=ans*10+a[i]-&apos;0&apos;; s=ans/b+&apos;0&apos;; ans%=b; c+=s; &#125; int pos=0; while(pos&lt;len &amp;&amp; c[pos]==&apos;0&apos;) pos++; if(pos==len) return &quot;0&quot;; return c.substr(pos);&#125; 这是模拟数式运算的一种实现方法。大家可以自己尝试一下。 总结 前导零 相加后的结果字长 字符串中存储的每一位的数字和我们已知的十进制表示法相反，也就是说高位在前，低位在后，而我们进行加减运算列等式的时候是低位对其进行计算，所以在计算前我们需要转换字符串的字符位置。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"大数","slug":"大数","permalink":"http://yoursite.com/tags/大数/"}]},{"title":"背包","slug":"背包","date":"2018-03-10T11:49:51.000Z","updated":"2018-03-17T13:19:07.919Z","comments":true,"path":"2018/03/10/背包/","link":"","permalink":"http://yoursite.com/2018/03/10/背包/","excerpt":"","text":"背包 背包简介问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。我们讨论三种背包方式。 01背包 完全背包 多重背包算法描述 01背包 有n个重量和价值分别为Wi，vi的物品，从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 我们设置状态转移方程dp[i][j]表示前i个物品在总重量小于等于j的情况下挑选的价值总和最大值。那么存在一个转移方程dp[i][j]=max(dp[i-1][j],dp[i-1][j-wi]+vi)如何理解呢？我们通过前i-1个物品推导出前i个物品的转移方程，如果我们取第i个物品，dp[i][j]=dp[i-1][j-wi]+vi如果我们不取第i个物品，dp[i][j]=dp[i-1][j]我们可以通过逆序来压缩掉一维空间dp[j]=max(dp[j],dp[j-wi]+vi)因为dp[j-wi]+vi此时保存的是dp[i-1][j-wi]+vi 完全背包 有n种重量和价值分别为wi，vi的物品。从这些物品中挑选总质量不超过W的物品，求出挑选物品质量价值总和的最大值。在这里，每种物品可以挑选任意多件。 其实01背包针对的问题是咱们每个物品只能挑选一次，而完全背包则是每个物品我们可以挑选任意多次。那么我们的状态状态转移方程可以写成：dp[i][j]=max(dp[i-1][j-k*wi]+k*vi)k大于等于0，且k*wi小于j我们可以将其优化为：dp[i][j]=max(dp[i][j],dp[i-1][j-wi]+vi)此时我们也可以降掉一维空间。使其满足``dp[j]=max(dp[j],dp[j-wi]+vi) 多重背包 有n种重量和价值分别为wi，vi的物品。从这些物品中挑选总质量不超过W的物品，求出挑选物品质量价值总和的最大值。在这里，每种物品最多可以挑选ni件。 其实这也是01背包的变形。dp[i][j]=max(dp[i-1][j-k*wi]+k*vi)0&lt;=k&lt;=ni，且k*wi小于j同时我们也可以通过二进制压缩来减小k的值。如果我们不进行压缩，我们需要遍历ni次如果我们进行压缩，那么我们需要遍历log(ni)次。二进制压缩的思想是将k分成2，4，8，16等等部分。假设k=10；我们分为2，4，4一共三份，(最后一份是10-2-4)那么此时2-》wi等同于2*wi，vi等同于2*vi4-》wi等同于4*wi，vi等同于4*vi4-》wi等同于4*wi，vi等同于4*vi每一个部分记录它的质量和体积，等同于多加了三个01背包的部分。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990c[i]表示体积w[i]表示重量//01背包for(int i=0;i&lt;N:i++)&#123; for(int j=V;j&gt;=c[i];j--) f[j]=max(f[j],f[j-c[i]]+w[i]);&#125;//完全背包for(int i=0;i&lt;N;i++)&#123; for(int j=c[i];j&lt;=V;j++) f[j]=max(f[j],f[j-c[i]]+w[i]);&#125;//多重背包for(int i=0;i&lt;N;i++)&#123; for(int k=1;k&lt;n[i];n[i]-=k,k&lt;&lt;=1) for(int j=V;j&gt;=k*c[i];j--) f[j]=max(f[j],f[j-k*c[i]]+k*w[i]); for(int j=V;j&gt;=n[i]*c[i];j--) f[j]=max(f[j],f[j-n[i]*c[i]]+n[i]*w[i]);&#125;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 101;const int SIZE = 50001;int dp[SIZE];int volume[MAXN], value[MAXN], c[MAXN];int n, v; // 总物品数，背包容量// 01背包void ZeroOnepark(int val, int vol)&#123; for (int j = v ; j &gt;= vol; j--) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;// 完全背包void Completepark(int val, int vol)&#123; for (int j = vol; j &lt;= v; j++) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;// 多重背包void Multiplepark(int val, int vol, int amount)&#123; if (vol * amount &gt;= v) &#123; Completepark(val, vol); &#125; else &#123; int k = 1; while (k &lt; amount) &#123; ZeroOnepark(k * val, k * vol); amount -= k; k &lt;&lt;= 1; &#125; if (amount &gt; 0) &#123; ZeroOnepark(amount * val, amount * vol); &#125; &#125;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; v) &#123; for (int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; c[i]; // 费用，价值，数量 &#125; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; Multiplepark(value[i], volume[i], c[i]); &#125; cout &lt;&lt; dp[v] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"}]},{"title":"考研规划","slug":"考研规划","date":"2018-03-08T11:30:23.000Z","updated":"2018-03-08T15:27:11.491Z","comments":true,"path":"2018/03/08/考研规划/","link":"","permalink":"http://yoursite.com/2018/03/08/考研规划/","excerpt":"","text":"高数： 阶段 复习教材以及习题 时间 基础巩固 数学教材（高数概率论线代）+张宇36讲 3-&gt;6月 基础巩固数学根据去年（2018年）大纲来复习书上的内容张宇36讲配套教材来吃透教材，形成知识链不要急，时间来得及 英语： 阶段 复习教材以及习题 时间 基础巩固 单词+阅读+语法 3-&gt;6月 基础巩固单词：恋练有词，希望可以过多边单词书阅读：我还是使用扇贝阅读，阅读需要配套翻译语法：刘晓艳长难句不要急，基础是重点，高楼平地起，没有基础，便没有提高","categories":[{"name":"Lifes","slug":"Lifes","permalink":"http://yoursite.com/categories/Lifes/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/tags/考研/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2018-03-07T16:04:36.000Z","updated":"2018-03-09T12:58:16.717Z","comments":true,"path":"2018/03/08/拓扑排序/","link":"","permalink":"http://yoursite.com/2018/03/08/拓扑排序/","excerpt":"","text":"拓扑排序算法简介 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边 uv,u 在排序中都在v之前。 例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径。也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。(转自维基百科) 算法描述我们一般存在两种算法实现方法 dfs 其实DFS就是深度优先搜索，它每次都沿着一条路径一直往下搜索，知道某个顶点没有了出度时，就停止递归，往回走，所以我们就用DFS的这个思路，我们可以得到一个有向无环图的拓扑序列，其实DFS很像Kahn算法的逆过程。 根据出入度（称之为Kahn算法） 在有向图中选一个没有前驱的顶点并且输出从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//使用dfsint n, G[maxn][maxn], c[maxn], topo[maxn], t;/* *n表示邻接表的个数， *c[]表示状态，为1表示访问过，为0表示未访问，为-1表示正在访问 *topo表示排完序的拓扑序列 */bool dfs(int u)&#123; c[u] = -1; for(int v = 0; v &lt; n; v++) if(G[u][v]) &#123; if(c[v]&lt;0) return false; //表示v也在被访问，说明u和v在一个环中，说明输入数据有问题，非DAG else if(!c[v]&amp;&amp;!dfs(v)) return false; //说明v没有被访问，但是以v为起始节点的时候，v存在环。 &#125; c[u] = 1; topo[--t]=u; //深搜到最后一个u的时候，topo[n-1]赋值为u return true;&#125;bool toposort()&#123; t = n; memset(c, 0, sizeof(c)); for(int u = 0; u &lt; n; u++) if(!c[u]) if(!dfs(u)) return false; return true;&#125;////////////////////////////////////////使用出度入度的思想int G[MAXN][MAXN];//路径int in_degree[MAXN];//入度int ans[MAXN];//路径int n;//顶点void toposort()&#123; for(i = 1; i &lt;= n; i++) &#123; for(j = 1; j &lt;= n; j++) &#123; if(G[i][j]) &#123; in_degree[j]++; &#125; &#125; &#125; for(i = 1; i &lt;= n; i++)//从最小的开始寻找， &#123;//这样保证了有多个答案时序号小的先输出 int k = 1; while(in_degree[k] != 0)//寻找入度为零的点 k++; ans[i] = k; in_degree[k] = -1; //更新为-1，后边检测不受影响，相当于删除节点 for(int j = 1; j &lt;= n; j++) &#123; if(G[k][j]) in_degree[j]--;//相关联的入度减1 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"最小生成树","slug":"最小生成树","date":"2018-03-07T16:03:34.000Z","updated":"2018-03-08T15:28:40.338Z","comments":true,"path":"2018/03/08/最小生成树/","link":"","permalink":"http://yoursite.com/2018/03/08/最小生成树/","excerpt":"","text":"最小生成树算法简介一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。简言之就是在一个连通图中找出一些边使得所有节点联通。 算法描述虽然有很多可以实现最小生成树的算法，我们只讨论Kruskal算法。 Kruskal（克鲁斯科尔算法）该算法算是贪心算法的引用 步骤： 新建图G，G中拥有原图中相同的节点，但没有边 将原图中所有的边按权值从小到大排序 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中 重复3，直至图G中所有的节点都在同一个连通分量中代码描述我们间接通过并查集来实现判断是否两个节点存在于同一个连通分量1234567891011121314151617181920212223242526272829303132333435int f[maxn];int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125;void join(int u,int v)&#123; int fu=find(u); int fv=find(v); if(fu!=fv)&#123; f[fu]=fv; &#125;&#125;struct edge&#123; int from,to,cost; friend bool operator &lt;(edge a,edge b)&#123; return a.cost&lt;b.cost; &#125;&#125;Ed[maxn];int V,E;int kruskal()&#123; sort(Ed,Ed+E); iniuni(V); int res=0; for(int i=0;i&lt;E;i++)&#123; edge e=Ed[i]; int fu=find(Ed[i].from); int fv=find(Ed[i].to); if(fu!=fv)&#123; join(e.from,e.to); res+=e.cost; &#125; &#125; return res;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"并查集","slug":"并查集","date":"2018-03-07T00:06:19.000Z","updated":"2018-03-07T00:32:19.880Z","comments":true,"path":"2018/03/07/并查集/","link":"","permalink":"http://yoursite.com/2018/03/07/并查集/","excerpt":"","text":"并查集概念简介在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。 为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。 算法描述用集合中的某个元素来代表这个集合，该元素称为集合的代表元。一个集合内的所有元素组织成以代表元为根的树形结构。在并查集算法中，合并操作是将该元素所在树连接在被合并元素所在树上。对于查找操作，即是路经查找到树根，确定代表元的过程。 判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。 优化存在两种优化算法： 按秩合并：使包含较少结点的树根指向包含较多结点的树根。 路径压缩：使路径查找上的每个点都直接指向根结点。路径压缩是一种在执行“查找”时扁平化树结构的方法。关键在于在路径上的每个节点都可以直接连接到根上；他们都有同样的表示方法。为了达到这样的效果，Find递归地经过树，改变每一个节点的引用到根节点。得到的树将更加扁平，为以后直接或者间接引用节点的操作加速。关键代码在find12345int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125; 完整代码描述 递归版本(存在溢出的情况) 12345678910111213int f[maxn];int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125;void join(int u,int v)&#123; int fu=find(u); int fv=find(v); if(fu!=fv)&#123; f[fu]=fv; &#125;&#125; 非递归版本 12345678910111213141516171819202122232425262728int pre[1000 ];void ini()//初始化，表示每个结点的父节点是其本身&#123; for(int i=0;i&lt;maxn;i++) pre[i]=i;&#125;int find(int x)//查找根节点&#123; int r=x; while ( pre[r] != r )//返回根节点 r r=pre[r]; int i=x,j; while(i!=r) //路径压缩 &#123; j = pre[i]; //在改变上级之前用临时变量 j 记录下他的值 pre[i]= r ; //把上级改为根节点 i=j; &#125; return r ;&#125;void join(int x,int y)//判断x y是否连通，//如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,&#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx]=fy;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"最短路算法","slug":"最短路算法","date":"2018-02-27T12:26:01.000Z","updated":"2018-03-01T07:38:12.145Z","comments":true,"path":"2018/02/27/最短路算法/","link":"","permalink":"http://yoursite.com/2018/02/27/最短路算法/","excerpt":"","text":"最短路算法松弛操作 松弛：v-&gt;w的距离可以通过p点来缩短，即dis（v,w）&lt;dis(v,p)+dis(p,w) Dijkstra算法（单源最短路）维基简介： 戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。 算法描述 这个算法是通过为每个顶点 v 保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。 说人话！！！ 就是我们通过bfs遍历每一个点（通过边），当遍历到u点时，我们已知u点的邻边以及邻边的另一端的顶点v。我们通过u点来更新s到v的距离。代码描述就是：1234if(dis[v]&lt;dis[u]+edge(u,v))&#123; dis[v]=dis[u]+edge(u,v); //edge(u,v)表示u，v间边的距离。&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e4+10;const int INF=0x3f3f3f3f;struct edge&#123; int to,cost; edge(int to,int cost)&#123; this-&gt;to=to; this-&gt;cost=cost; &#125;&#125;;typedef pair&lt;int,int&gt;point;int dis[maxn];vector&lt;edge&gt;Ed[maxn];void addEdge(int u,int v,int value)&#123; Ed[u].push_back(edge(v,value));&#125;void Dijkstra(int s,int n)&#123; for(int i=0;i&lt;=n;i++)dis[i]=INF; dis[s]=0; priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q; q.push(point(dis[s],s)); while(!q.empty())&#123; point cur=q.top(); q.pop(); int v=cur.second; for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); &#125; &#125; &#125;&#125; spfa算法（单源最短路并且判负环）存在的原因我们在使用Dijstra算法时，如果出现负环，我们无法得出正确答案。我们来分析一下Dijstra算法的代码实现部分1234567for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); &#125;&#125; 我们运行一下如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e4+10;const int INF=0x3f3f3f3f;struct edge&#123; int to,cost; edge(int to,int cost)&#123; this-&gt;to=to; this-&gt;cost=cost; &#125;&#125;;typedef pair&lt;int,int&gt;point;int dis[maxn];vector&lt;edge&gt;Ed[maxn];void addEdge(int u,int v,int value)&#123; Ed[u].push_back(edge(v,value));&#125;void Dijkstra(int s,int n)&#123; for(int i=0;i&lt;=n;i++)dis[i]=INF; dis[s]=0; priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q; q.push(point(dis[s],s)); cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;s&lt;&lt;&quot; 距离为&quot;&lt;&lt;dis[s]&lt;&lt;endl; while(!q.empty())&#123; point cur=q.top(); q.pop(); int v=cur.second; for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;e.to&lt;&lt;&quot; 距离为&quot;&lt;&lt;dis[e.to]&lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123; addEdge(0,1,2); addEdge(1,0,2); addEdge(0,2,1); addEdge(2,0,1); addEdge(1,2,-5); addEdge(2,1,-5); Dijkstra(0,3); return 0;&#125; 我们构造了一个负环，（0，1，2）（无向图）0号节点与1号节点相连，距离为20号节点与2号节点相连，距离为11号节点与2号节点相连，距离为-5运行结果如图：我们知道Dijkstra算法是通过不断更新相邻点的最小距离，由于存在负数，越更新，距离越小（负数越加越小），所以无法得出正确结论，甚至无法跳出循环。 算法描述其实和Dijkstra没有什么区别，只是加了判负环的操作。判负环的操作：我们一共有n个点，如果我们要得到最短路，不会有重复的路径。其次，对于一个点，与其相邻的最多有n-1个，即该点最多可以被更新n-1次。所以，我们只需要记录一个点入栈多少次，如果大于n-1，（或者n）则一定存在负权还。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 时间复杂度O(kE) * 队列实现，有时候改成栈实现会更快，较容易修改 */const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge&#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125;bool vis[MAXN]; // 在队列标志int cnt[MAXN]; // 每个点的入列队次数int dist[MAXN];bool SPFA(int start, int n)&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; while (!que.empty()) &#123; que.pop(); &#125; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) &#123; return false; // cnt[i]为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; &#125; return true;&#125; Floyd-Warshall算法（多源最短路）维基简介 Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N^3)，空间复杂度为O(N2)。 算法描述Floyd-Warshall算法的原理是动态规划我们假设只使用顶点0~k和i，j的情况下，记录i到j的最短路长度为d[k+1][i][j]所以d[0][i][j]表示不使用中间节点是i到j的距离，那么直接等于cost[i][j]我们分成两种情况： 不经过顶点kd[k][i][j]=d[k-1][i][j]; 经过顶点kd[k][i][j]=d[k-1][i][k]+d[k-1][k][j]; 所以，我们可以得知d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]);同时，我们可以去掉一维数组d[i][j]=min(d[i][k],d[k][j]) 代码实现1234567891011121314151617181920212223242526272829303132/* * Floyd算法，求从任意节点i到任意节点j的最短路径 * cost[][]:初始化为INF（cost[i][i]：初始化为0） * lowcost[][]:最短路径，path[][]:最短路径（无限制） */const int MAXN = 100;int cost[MAXN][MAXN];int lowcost[MAXN][MAXN];int path[MAXN][MAXN];void Floyd(int n)&#123; memcpy(lowcost, cost, sizeof(cost)); memset(path, -1, sizeof(path)); for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (lowcost[i][j] &gt; (lowcost[i][k] + lowcost[k][j])) &#123; lowcost[i][j] = lowcost[i][k] + lowcost[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125; return ;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"3月计划","slug":"3月计划","date":"2018-02-26T15:27:43.000Z","updated":"2018-02-26T15:42:11.640Z","comments":true,"path":"2018/02/26/3月计划/","link":"","permalink":"http://yoursite.com/2018/02/26/3月计划/","excerpt":"","text":"需要准备的事情： 蓝桥杯时间是2018年4月1日星期天 天梯赛时间是2018年3月31日13:00——16:00 考研安排 刷团队设计天梯赛往年的题目（认真刷level2的题目，lever3的题目写不来，level2的题目可以争取一下） 重新刷一遍杭电2000到2100的题目，并加以总结 刷一遍历届试题（重点刷这个） 算法归纳总结： 搜索 dfs bfs 枚举 贪心 贪心 动态规划 简单DP（找规律） 背包 树形DP 数位DP 数据结构 二叉树相关 优先队列相关 并查集 线段树 图论 最短路算法 最小生成树 拓扑排序 数论 gcd 扩展gcd 素数相关 逆元 斯特林近似 快速幂 矩阵快速幂 卡塔兰数 一元线性同余方程 字符串 kmp 字符串距离 代数几何 凸包 判断三点方向 多边形面积 最小点对 四点共面 多边形重心 奇技淫巧 二分查找 尺取法 随机化算法 大数算法（蓝桥杯报了c++组，坑呀） 加 减 乘 博弈 简单博弈（三种）","categories":[{"name":"Lifes","slug":"Lifes","permalink":"http://yoursite.com/categories/Lifes/"}],"tags":[{"name":"计划","slug":"计划","permalink":"http://yoursite.com/tags/计划/"}]},{"title":"c++继承之虚继承","slug":"c-继承之虚继承","date":"2018-02-26T12:43:12.000Z","updated":"2018-02-26T12:59:23.020Z","comments":true,"path":"2018/02/26/c-继承之虚继承/","link":"","permalink":"http://yoursite.com/2018/02/26/c-继承之虚继承/","excerpt":"","text":"虚继承存在的理由 存在即合理 虽然我们相信这句话，但是为什么合理呢？是什么促使它存在的呢？我们引出一个概念，菱形继承什么是菱形继承：1234567891011121314151617181920class A //大小为4&#123;public: int a;&#125;;class B : public A&#123;public: int b;&#125;;class C : public A&#123;public: int c;&#125;;class D :public B, public C&#123;public: int d;&#125;; 我们画出它的类图，会发现是一个菱形当我们实例化D类,对象是d，并且调用d.a;那么会出现二义性的问题。通过引入虚函数，可以解决以下问题： 二义性问题 浪费存储空间 实现原理 每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间） 虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了 当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 我的理解是通过偏移地址，找到虚基类成员，如果两个父类的父类是一个类，类似于B的父类是A，C的父类是A，B，C父类相同，那么我们不需要两份相同的继承。 代码示例1234567891011121314151617181920class A&#123;public: int a;&#125;;class B :virtual public A&#123;public: int b;&#125;;class C :virtual public A&#123;public: int c;&#125;;class D :public B, public C&#123;public: int d;&#125;; 注意virtual的位置。","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之多重继承和多继承","slug":"c-继承之多重继承和多继承","date":"2018-02-25T08:18:04.000Z","updated":"2018-02-25T08:36:39.299Z","comments":true,"path":"2018/02/25/c-继承之多重继承和多继承/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之多重继承和多继承/","excerpt":"","text":"多重继承概念多重继承是一个类的父类也有父类。多重继承的对象初始化方式最高的父类到子类。A()–&gt;B–&gt;C()销毁时正好是初始化的反顺序。~C–&gt;~B–&gt;A()代码示例为：123class A&#123;&#125;;class B:public A&#123;&#125;;class C:public B&#123;&#125;; 特点： 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。 多继承概念多继承是一个类有2个以上父类。多继承的对象初始化方式是父类依次初始化。A()–&gt;B–&gt;AB()销毁时正好是初始化的反顺序。~AB–&gt;~B()–&gt;A~() 代码示例123class A&#123;&#125;;class B&#123;&#125;;class AB:public A,public B&#123;&#125;;","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之is_a和has_a","slug":"c-继承之is-a和hasas-a","date":"2018-02-25T08:17:34.000Z","updated":"2018-02-25T08:36:53.319Z","comments":true,"path":"2018/02/25/c-继承之is-a和hasas-a/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之is-a和hasas-a/","excerpt":"","text":"is_a原则概念举一个例子，有一个Horse类可以保存关于马的所有信息，身高体重等等，那么我们就可以从Horse类中派生出白马类，白马类包含所有Horse类的成员，在白马类中可以新增关于白马的成员，这个成员通常不用于Horse类。1234567891011class Horse&#123;public: int Tall; int Weight;&#125;;class WhiteHorse:public Horse&#123;public: int Color;&#125;; 上面的代码中，WhiteHorse多了颜色这个成员。整体来看，is-a表示了一种是的关系。比如白马是马，香蕉是水果，老师是人这种关系。并且public的继承方式建立了is_a的关系。 使用实例派生类Soldier继承自基类Person123456789101112131415161718192021222324//Person.hclass Person&#123;public: Person(string name = &quot;Jim&quot;); ~Person(); void play();protected: string m_strName;&#125;;//Soldier.hclass Soldier : public Person&#123;public: Soldier(string name = &quot;James&quot;, int age = 20); ~Soldier(); void work();protected: int m_iAge;&#125;; 派生类可以给基类赋值：1234567//main.cppint main()&#123; Soldier s1; Person p1 = s1; return 0;&#125; 因为一个士兵也是一个人。 基类指针可以指向派生类(派生类可以取地址给基类)：1234567//main.cppint main()&#123; Soldier s1; Person *p2 = &amp;s1; return 0;&#125; 同理，一个士兵也是一个人，父类的指针也可以指向子类对象。 把基类的指针或者是基类的对象或者是基类的引用作为函数的参数来使它可以接收所传入的子类的对象，并且也可以传入基类的对象 1234567891011121314151617void func1(Person *p)&#123; ......&#125;void func2(Person &amp;p)&#123; ......&#125;//main.cppint main()&#123; Person p1; Soldier s1; func1(&amp;p1); func2(p1); func1(&amp;s1); func2(s1); return 0;&#125; 基类只能接收和访问派生类中自己有的数据成员和成员函数 123456789101112131415//#include &quot;Person.h&quot;# include &quot;Soldier.h&quot;int main() &#123; Soldier soldier; Person person; person = soldier; person.play(); Person *p = &amp;soldier; p-&gt;play(); // 使用基类声明的对象只能调用基类的方法 //p-&gt;work(); // 使用基类声明的对象不能调用派生类的方法 return 0;&#125; 如果需要调用子类的成员函数，那么就是多态的内容了，后面再说。这是在编译期就决定了的。 通过基类的指针指向派生类的对象123456789101112131415//#include &quot;Person.h&quot;#include &quot;Soldier.h&quot;int main() &#123; Person *pp = new Soldier; // 基类的指针去指向派生类的内存空间 pp-&gt;play(); delete pp; // 销毁基类的对象，执行的是基类的析构函数，派生类的内存并没有释放 pp = NULL; return 0;&#125;LOG:Person::play()JamesPerson::~Person() has_a原则概念&emsp;&emsp;has-a体现了有这个思想。&emsp;&emsp;比如，午餐有香蕉。但是午餐不是香蕉。&emsp;&emsp;其实私有跟保护继承体现了has-a原则是因为，私有跟保护继承是实现继承。&emsp;&emsp;什么是实现继承呢？&emsp;&emsp;实现继承的主要目标是代码重用，我们发现类B和类C存在同样的代码，因此我们设计了一个类 A，用于存放通用的代码，基于这种思路的继承称为实现继承。&emsp;&emsp;我们可以说，午餐中存在香蕉。&emsp;&emsp;而共有继承则不是，为什么？ 在需要基类对象的任何地方都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。那么就可得到，当为私有或保护继承的时候，是包含的关系，基类在派生类中是私有的。需要基类的时候是不能用派生类代替的。 两种情况 包含 12345678class Banana&#123;..&#125;;class Lauch&#123; private: class Banana; ......&#125;; 私有继承c++还有另一种实现has-a关系的途径—-私有继承。 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。 使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口，这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。简而言之，派生类不能继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。 因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。 使用包含还是私有继承 &emsp;&emsp;大多数c++程序员倾向于前者。不过私有继承所提供的特性确实比包含多。例如，假设类包含保护成员，则这样的成员在派生类中是可用的，但在继承层次机构外是不可用的。如果使用组合奖这样的类保护在另一类中，则后者将不是排成类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承的到的将是派生类，因此他能够访问保护成员。 另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之隐藏","slug":"c-继承之隐藏","date":"2018-02-25T08:16:53.000Z","updated":"2018-02-25T08:36:50.804Z","comments":true,"path":"2018/02/25/c-继承之隐藏/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之隐藏/","excerpt":"","text":"隐藏概念：隐藏是指派生类的函数屏蔽了与其同名的基类函数。 代码实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()&#123; cout&lt;&lt;&quot;Person的构造函数&quot;&lt;&lt;endl; &#125; ~Person()&#123; cout&lt;&lt;&quot;Person的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Person的eat函数&quot;&lt;&lt;endl; &#125;private: int m_iAge; string m_strName;&#125;;class Worker :public Person&#123;public: Worker()&#123; cout&lt;&lt;&quot;Worker的构造函数&quot;&lt;&lt;endl; &#125; ~Worker()&#123; cout&lt;&lt;&quot;Worker的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Worker的eat函数&quot;&lt;&lt;endl; &#125; void work()&#123; cout&lt;&lt;&quot;Worker的work函数&quot;&lt;&lt;endl; &#125;private: int m_iSalary;&#125;;int main()&#123; Worker w; w.eat(); w.Person::eat(); return 0;&#125; 运行结果为：12345678910Person的构造函数Worker的构造函数Worker的eat函数Person的eat函数Worker的析构函数Person的析构函数--------------------------------Process exited after 0.1206 seconds with return value 0请按任意键继续. . . 简易解释 Worker是子类，Person是父类，我们在栈上实例化子类方法，首先调用父类构造函数，其次调用子类构造函数。析构函数则反之，并且栈上的空间是由系统管理，系统调用析构函数。 父类中的eat()函数被隐藏，w.eat()调用的是子类的eat()函数。 如果我们需要调用父类的成员函数，可以采用w.Person::eat();的方法。 几个易混淆的名词 隐藏：不解释了 覆盖或者称之为重写（override）如果我们没有在子类中定义同名的虚函数，那么在子类虚函数表当中就会写上父类当中那个虚函数的函数入口地址，如果我们在子类中也定义了同名的虚函数，那么在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。 如何记忆隐藏并没有消失，可以通过特殊的手段访问，数据成员也有隐藏这种现象。而覆盖则是在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。（后续会有博客详细解释）","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承方式","slug":"c-继承方式","date":"2018-02-25T07:36:58.000Z","updated":"2018-02-25T08:36:45.566Z","comments":true,"path":"2018/02/25/c-继承方式/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承方式/","excerpt":"","text":"c++继承（三种继承方式）三种继承方式 共有继承公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 私有继承私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 保护继承保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。继承方式之间的关系 继承方式 基类的public成员 基类的protected成员 基类的private成员 public 成为public成员 成为protected成员 不可见 protected 成为protected成员 成为protected成员 不可见 private 成为private成员 成为private成员 不可见 注意事项 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。 在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；简单总结三种类成员访问限定符 public（共有） protected（保护） private（私有）三种继承关系 public（共有继承） protected（保护继承） private(私有继承)","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-08T08:49:36.568Z","updated":"2018-02-25T08:09:44.759Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Clean cache1$ hexo clean Generate static files1$ hexo generate More info: Generating Compress code using gulp1$ gulp More info: Gulp Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}