{"meta":{"title":"Jamence's blog","subtitle":"everything is funny when you are exploring","description":"Jamence的个人博客","author":"Jamence","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-25T08:11:31.432Z","updated":"2018-02-25T08:11:31.432Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I am nobody with curiosity. Three virtue you should pay attention Laziness The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and document what you wrote so you don’t have to answer so many questions about it. Hence, the first great virtue of a programmer, Also hence, this book. Impatience The anger you feel when the computer is being lazy. This makes you write programs that don’t just react to your needs, but actually anticipate them. Or at least pretend to. Hence, the second great virtue of a programmer. Hubris Excessive pride, the sort of thing Zeus zaps you for. Also the quality that makes you write (and maintain) programs that other people won’t want to say bad things about. Hence, the third great virtue of a programmer. 懒惰：是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。急躁：是这样一种愤怒——当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样。傲慢：极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序。"}],"posts":[{"title":"c++继承之多重继承和多继承","slug":"c-继承之多重继承和多继承","date":"2018-02-25T08:18:04.000Z","updated":"2018-02-25T08:36:39.299Z","comments":true,"path":"2018/02/25/c-继承之多重继承和多继承/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之多重继承和多继承/","excerpt":"","text":"多重继承概念多重继承是一个类的父类也有父类。多重继承的对象初始化方式最高的父类到子类。A()–&gt;B–&gt;C()销毁时正好是初始化的反顺序。~C–&gt;~B–&gt;A()代码示例为：123class A&#123;&#125;;class B:public A&#123;&#125;;class C:public B&#123;&#125;; 特点： 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。 多继承概念多继承是一个类有2个以上父类。多继承的对象初始化方式是父类依次初始化。A()–&gt;B–&gt;AB()销毁时正好是初始化的反顺序。~AB–&gt;~B()–&gt;A~() 代码示例123class A&#123;&#125;;class B&#123;&#125;;class AB:public A,public B&#123;&#125;;","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之is_a和has_a","slug":"c-继承之is-a和hasas-a","date":"2018-02-25T08:17:34.000Z","updated":"2018-02-25T08:36:53.319Z","comments":true,"path":"2018/02/25/c-继承之is-a和hasas-a/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之is-a和hasas-a/","excerpt":"","text":"is_a原则概念举一个例子，有一个Horse类可以保存关于马的所有信息，身高体重等等，那么我们就可以从Horse类中派生出白马类，白马类包含所有Horse类的成员，在白马类中可以新增关于白马的成员，这个成员通常不用于Horse类。1234567891011class Horse&#123;public: int Tall; int Weight;&#125;;class WhiteHorse:public Horse&#123;public: int Color;&#125;; 上面的代码中，WhiteHorse多了颜色这个成员。整体来看，is-a表示了一种是的关系。比如白马是马，香蕉是水果，老师是人这种关系。并且public的继承方式建立了is_a的关系。 使用实例派生类Soldier继承自基类Person123456789101112131415161718192021222324//Person.hclass Person&#123;public: Person(string name = &quot;Jim&quot;); ~Person(); void play();protected: string m_strName;&#125;;//Soldier.hclass Soldier : public Person&#123;public: Soldier(string name = &quot;James&quot;, int age = 20); ~Soldier(); void work();protected: int m_iAge;&#125;; 派生类可以给基类赋值：1234567//main.cppint main()&#123; Soldier s1; Person p1 = s1; return 0;&#125; 因为一个士兵也是一个人。 基类指针可以指向派生类(派生类可以取地址给基类)：1234567//main.cppint main()&#123; Soldier s1; Person *p2 = &amp;s1; return 0;&#125; 同理，一个士兵也是一个人，父类的指针也可以指向子类对象。 把基类的指针或者是基类的对象或者是基类的引用作为函数的参数来使它可以接收所传入的子类的对象，并且也可以传入基类的对象 1234567891011121314151617void func1(Person *p)&#123; ......&#125;void func2(Person &amp;p)&#123; ......&#125;//main.cppint main()&#123; Person p1; Soldier s1; func1(&amp;p1); func2(p1); func1(&amp;s1); func2(s1); return 0;&#125; 基类只能接收和访问派生类中自己有的数据成员和成员函数 123456789101112131415//#include &quot;Person.h&quot;# include &quot;Soldier.h&quot;int main() &#123; Soldier soldier; Person person; person = soldier; person.play(); Person *p = &amp;soldier; p-&gt;play(); // 使用基类声明的对象只能调用基类的方法 //p-&gt;work(); // 使用基类声明的对象不能调用派生类的方法 return 0;&#125; 如果需要调用子类的成员函数，那么就是多态的内容了，后面再说。这是在编译期就决定了的。 通过基类的指针指向派生类的对象123456789101112131415//#include &quot;Person.h&quot;#include &quot;Soldier.h&quot;int main() &#123; Person *pp = new Soldier; // 基类的指针去指向派生类的内存空间 pp-&gt;play(); delete pp; // 销毁基类的对象，执行的是基类的析构函数，派生类的内存并没有释放 pp = NULL; return 0;&#125;LOG:Person::play()JamesPerson::~Person() has_a原则概念&emsp;&emsp;has-a体现了有这个思想。&emsp;&emsp;比如，午餐有香蕉。但是午餐不是香蕉。&emsp;&emsp;其实私有跟保护继承体现了has-a原则是因为，私有跟保护继承是实现继承。&emsp;&emsp;什么是实现继承呢？&emsp;&emsp;实现继承的主要目标是代码重用，我们发现类B和类C存在同样的代码，因此我们设计了一个类 A，用于存放通用的代码，基于这种思路的继承称为实现继承。&emsp;&emsp;我们可以说，午餐中存在香蕉。&emsp;&emsp;而共有继承则不是，为什么？ 在需要基类对象的任何地方都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。那么就可得到，当为私有或保护继承的时候，是包含的关系，基类在派生类中是私有的。需要基类的时候是不能用派生类代替的。 两种情况 包含 12345678class Banana&#123;..&#125;;class Lauch&#123; private: class Banana; ......&#125;; 私有继承c++还有另一种实现has-a关系的途径—-私有继承。 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。 使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口，这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。简而言之，派生类不能继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。 因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。 使用包含还是私有继承 &emsp;&emsp;大多数c++程序员倾向于前者。不过私有继承所提供的特性确实比包含多。例如，假设类包含保护成员，则这样的成员在派生类中是可用的，但在继承层次机构外是不可用的。如果使用组合奖这样的类保护在另一类中，则后者将不是排成类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承的到的将是派生类，因此他能够访问保护成员。 另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之隐藏","slug":"c-继承之隐藏","date":"2018-02-25T08:16:53.000Z","updated":"2018-02-25T08:36:50.804Z","comments":true,"path":"2018/02/25/c-继承之隐藏/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之隐藏/","excerpt":"","text":"隐藏概念：隐藏是指派生类的函数屏蔽了与其同名的基类函数。 代码实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()&#123; cout&lt;&lt;&quot;Person的构造函数&quot;&lt;&lt;endl; &#125; ~Person()&#123; cout&lt;&lt;&quot;Person的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Person的eat函数&quot;&lt;&lt;endl; &#125;private: int m_iAge; string m_strName;&#125;;class Worker :public Person&#123;public: Worker()&#123; cout&lt;&lt;&quot;Worker的构造函数&quot;&lt;&lt;endl; &#125; ~Worker()&#123; cout&lt;&lt;&quot;Worker的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Worker的eat函数&quot;&lt;&lt;endl; &#125; void work()&#123; cout&lt;&lt;&quot;Worker的work函数&quot;&lt;&lt;endl; &#125;private: int m_iSalary;&#125;;int main()&#123; Worker w; w.eat(); w.Person::eat(); return 0;&#125; 运行结果为：12345678910Person的构造函数Worker的构造函数Worker的eat函数Person的eat函数Worker的析构函数Person的析构函数--------------------------------Process exited after 0.1206 seconds with return value 0请按任意键继续. . . 简易解释 Worker是子类，Person是父类，我们在栈上实例化子类方法，首先调用父类构造函数，其次调用子类构造函数。析构函数则反之，并且栈上的空间是由系统管理，系统调用析构函数。 父类中的eat()函数被隐藏，w.eat()调用的是子类的eat()函数。 如果我们需要调用父类的成员函数，可以采用w.Person::eat();的方法。 几个易混淆的名词 隐藏：不解释了 覆盖或者称之为重写（override）如果我们没有在子类中定义同名的虚函数，那么在子类虚函数表当中就会写上父类当中那个虚函数的函数入口地址，如果我们在子类中也定义了同名的虚函数，那么在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。 如何记忆隐藏并没有消失，可以通过特殊的手段访问，数据成员也有隐藏这种现象。而覆盖则是在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。（后续会有博客详细解释）","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承方式","slug":"c-继承方式","date":"2018-02-25T07:36:58.000Z","updated":"2018-02-25T08:36:45.566Z","comments":true,"path":"2018/02/25/c-继承方式/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承方式/","excerpt":"","text":"c++继承（三种继承方式）三种继承方式 共有继承公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 私有继承私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 保护继承保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。继承方式之间的关系 继承方式 基类的public成员 基类的protected成员 基类的private成员 public 成为public成员 成为protected成员 不可见 protected 成为protected成员 成为protected成员 不可见 private 成为private成员 成为private成员 不可见 注意事项 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。 在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；简单总结三种类成员访问限定符 public（共有） protected（保护） private（私有）三种继承关系 public（共有继承） protected（保护继承） private(私有继承)","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-08T08:49:36.568Z","updated":"2018-02-25T08:09:44.759Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Clean cache1$ hexo clean Generate static files1$ hexo generate More info: Generating Compress code using gulp1$ gulp More info: Gulp Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}