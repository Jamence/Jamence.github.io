{"meta":{"title":"Jamence's blog","subtitle":"everything is funny when you are exploring","description":"Jamence的个人博客","author":"Jamence","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-25T08:11:31.432Z","updated":"2018-02-25T08:11:31.432Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I am nobody with curiosity. Three virtue you should pay attention Laziness The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and document what you wrote so you don’t have to answer so many questions about it. Hence, the first great virtue of a programmer, Also hence, this book. Impatience The anger you feel when the computer is being lazy. This makes you write programs that don’t just react to your needs, but actually anticipate them. Or at least pretend to. Hence, the second great virtue of a programmer. Hubris Excessive pride, the sort of thing Zeus zaps you for. Also the quality that makes you write (and maintain) programs that other people won’t want to say bad things about. Hence, the third great virtue of a programmer. 懒惰：是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。急躁：是这样一种愤怒——当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样。傲慢：极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序。"}],"posts":[{"title":"动态规划","slug":"动态规划","date":"2018-04-18T14:24:58.000Z","updated":"2018-04-19T13:27:40.624Z","comments":true,"path":"2018/04/18/动态规划/","link":"","permalink":"http://yoursite.com/2018/04/18/动态规划/","excerpt":"","text":"线性DP简单的线性递推每一项都是由他的前一项递推而来，例如当m=2，c1=c2=a1=a2=1时，是斐波那契数列。咱们需要算出第n项，咋算：使用矩阵快速幂：对于如下方程，对于更加复杂的内容，我们可以通过如下操作 最长上升子序列首先，我们都知道一个n平方的DP做法，我们假设dp[i]是以a[i]结尾的最长上升子序列的值，那么我们可以找到递推式， 我们可以进行一系列的优化：我们主要通过二分来优化。由于该做法并没有直接算出最终子序列的结果，我们可以通过一个pre数组来指定该字符之前的字符号码。 数字三角形EXT想必大家都知道数字三角形的原型了。我们来看几个变形： 将原问题中的使路径和最大改成使路径和模m最大。做法如下： 增加路径必须经过第r行，第c列这个条件做法：1）以（r，c）为头节点做一次DP，以（r，c）为底做一次DP2）在该位置增加一个极大的权值，最后的答案减去这个数（我们保证DP过程一定会经过该节点）。 背包问题我已经写了一部分，还有比较复杂的变种 二维背包之前咱们的背包只是讨论了一维空间的限制情况，二维背包指的是对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种代价，对于每种代价都有一个可以付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。咱们可以多加一个维度的状态便可以实现。同样咱们可以降维度，使用二维的数组。 分组背包有N件物品和一个容量为V的背包，第i件物品的费用是c[i],价值是w[i]，这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可以是这些物品的费用总和不超过背包容量，且价值总和最大。咱们设f[k][v]表示前k组物品花费费用用v能取得的最大权值。f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]},其中物品i属于组k咱们先枚举组，枚举容量，枚举物品。 区间DP顾名思义，就是在区间上进行动态规划。就是说，这类问题在进行一次决策之后，决策区间会有一个大区间分成两个小区间，问题也由一个规模较大的问题分解成两个规模较小的问题。咱们就可以从长度较小的区间向长度较长的区间进行递推。应用： 通过区间DP，求解回文数矩阵最右连乘问题考虑最后一次做乘法的为位置，这会将原问题分解成两个规模较小的子问题，咱们需要枚举最后一次乘法的位置，转移的复杂度是O(n),同时合法的子区间个数存在n平方总的时间复杂度是n三次方。 括号匹配1）使用卡塔兰数（出入栈的一种计算总个数的方法）2）区间DP石子归并如果不要求相邻的石子，最小生成树如果要求：dp[i][j]=min{dp[i][k]+dp[k+1][j]}+a[i]+......+a[j]如果石子不是沿着直线排列，而是连成一个环，那怎么办1）枚举还断开的时间，n4方的时间复杂度2）将原石子复制一份接在后面，令a[n+i]=a[i]，在长度为2n的石子串上做区间DP（对整体做区间DP，但是咱们得出结果是只是dp[i][i+n],i从1到n）决策单调性与不等式优化咱们甚至存在石子归并最初问题的n平方的时间复杂度。这就是四边形不等式优化树形DP 通常动态规划是线性的，一般在有向无环图上进行 树形DP是在树这种数据结构上进行的动态规划 树形DP有两种方向，自顶向下，自底向上 叶-&gt;根：在回溯的时候从叶子节点往上更新信息 根-&gt;叶：往往在从叶子往根dfs之后，在重新往下获得最后的答案。 没有上司的舞会（超级经典） 代码： 树的重心 代码： 树上最远距离 分析： 代码：","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"简单博弈","slug":"简单博弈","date":"2018-03-29T08:41:43.000Z","updated":"2018-03-29T08:49:09.646Z","comments":true,"path":"2018/03/29/简单博弈/","link":"","permalink":"http://yoursite.com/2018/03/29/简单博弈/","excerpt":"","text":"博弈我们就讨论简单博弈吧，复杂的我也不会呀 巴什博弈 问题描述： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 解决方法显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。 威佐夫博弈 问题描述： 有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 解决方法这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1，而 bk= ak + k &gt; ak-1 + k-1 = bk-1 &gt; ak-1 。所以性质1。成立。 2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b – bk个物体，即变为奇异局势；如果 a = ak ， b &lt; bk ,则同时从两堆中拿走 ak – ab + ak个物体,变为奇异局势（ ab – ak , ab – ak+ b – ak）；如果a &gt; ak ，b= ak + k,则从第一堆中拿走多余的数量a – ak 即可；如果a &lt; ak ，b= ak + k,分两种情况，第一种，a=aj （j &lt; k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – aj 即可。从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ak =[k（1+√5）/2]，bk= ak + k（k=0，1，2，…,n 方括号表示取整函数)奇妙的是其中出现了黄金分割数（1+√5）/2 = 1.618…,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1+ j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 尼姆博弈 问题描述 有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 解决方法这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结果：1 =二进制012 =二进制103 =二进制11 （+）———————0 =二进制00 （注意不进位） 对于奇异局势（0，n，n）也一样，结果也是0。 任何奇异局势（a，b，c）都有a（+）b（+）c =0。如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b&lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果: a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"博弈","slug":"博弈","permalink":"http://yoursite.com/tags/博弈/"}]},{"title":"线段树","slug":"线段树","date":"2018-03-29T08:41:26.000Z","updated":"2018-03-29T09:37:15.901Z","comments":true,"path":"2018/03/29/线段树/","link":"","permalink":"http://yoursite.com/2018/03/29/线段树/","excerpt":"","text":"概念线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。这是百度百科的解释，我理解的还比较浅，不是特别理解这里有一篇讲的比较好的博客可以推荐一下。 实现注意的事项： maxn 是题目给的最大区间,而节点数要开4 倍,确切的来说节点数要开大于maxn 的最小pow(2,x)的两倍 lson 和rson 分辨表示结点的左儿子和右儿子,由于每次传参数的时候都固定是这几个变量,所以可以用预定于比较方便的表示 PushUP(int rt)是把当前结点的信息更新到父结点 PushDown(int rt)是把当前结点的信息更新给儿子结点 rt 表示当前子树的根(root),也就是当前所在的结点 四大类别单点更新只更新叶子节点,然后把信息用PushUP(int r)这个函数更新上来示例： hdu1166(update:单点增减query:区间求和) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 55555;int sum[maxn&lt;&lt;2];void PushUP(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];&#125;void build(int l,int r,int rt) &#123; if (l == r) &#123; scanf(&quot;%d&quot;,&amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUP(rt);&#125;void update(int p,int add,int l,int r,int rt) &#123; if (l == r) &#123; sum[rt] += add; return ; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p , add , lson); else update(p , add , rson); PushUP(rt);&#125;int query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; int m = (l + r) &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret += query(L , R , lson); if (R &gt; m) ret += query(L , R , rson); return ret;&#125;int main() &#123; int T , n; scanf(&quot;%d&quot;,&amp;T); for (int cas = 1 ; cas &lt;= T ; cas ++) &#123; printf(&quot;Case %d:\\n&quot;,cas); scanf(&quot;%d&quot;,&amp;n); build(1 , n , 1); char op[10]; while (scanf(&quot;%s&quot;,op)) &#123; if (op[0] == &apos;E&apos;) break; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if (op[0] == &apos;Q&apos;) printf(&quot;%d\\n&quot;,query(a , b , 1 , n ,1)); else if (op[0] == &apos;S&apos;) update(a , -b , 1 , n , 1); else update(a , b , 1 , n , 1); &#125; &#125; return 0;&#125; hdu1754(update:单点替换query:区间最值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 222222;int MAX[maxn&lt;&lt;2];void PushUP(int rt) &#123; MAX[rt] = max(MAX[rt&lt;&lt;1] , MAX[rt&lt;&lt;1|1]);&#125;void build(int l,int r,int rt) &#123; if (l == r) &#123; scanf(&quot;%d&quot;,&amp;MAX[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUP(rt);&#125;void update(int p,int sc,int l,int r,int rt) &#123; if (l == r) &#123; MAX[rt] = sc; return ; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p , sc , lson); else update(p , sc , rson); PushUP(rt);&#125;int query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return MAX[rt]; &#125; int m = (l + r) &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret = max(ret , query(L , R , lson)); if (R &gt; m) ret = max(ret , query(L , R , rson)); return ret;&#125;int main() &#123; int n , m; while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; build(1 , n , 1); while (m --) &#123; char op[2]; int a , b; scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b); if (op[0] == &apos;Q&apos;) printf(&quot;%d\\n&quot;,query(a , b , 1 , n ,1)); else update(a , b , 1 , n , 1); &#125; &#125; return 0;&#125; hdu1394(update:单点增减query:区间求和) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 5555;int sum[maxn&lt;&lt;2];void PushUP(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];&#125;void build(int l,int r,int rt) &#123; sum[rt] = 0; if (l == r) return ; int m = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;void update(int p,int l,int r,int rt) &#123; if (l == r) &#123; sum[rt] ++; return ; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p , lson); else update(p , rson); PushUP(rt);&#125;int query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; int m = (l + r) &gt;&gt; 1; int ret = 0; if (L &lt;= m) ret += query(L , R , lson); if (R &gt; m) ret += query(L , R , rson); return ret;&#125;int x[maxn];int main() &#123; int n; while (~scanf(&quot;%d&quot;,&amp;n)) &#123; build(0 , n - 1 , 1); int sum = 0; for (int i = 0 ; i &lt; n ; i ++) &#123; scanf(&quot;%d&quot;,&amp;x[i]); sum += query(x[i] , n - 1 , 0 , n - 1 , 1); update(x[i] , 0 , n - 1 , 1); &#125; int ret = sum; for (int i = 0 ; i &lt; n ; i ++) &#123; sum += n - x[i] - x[i] - 1; ret = min(ret , sum); &#125; printf(&quot;%d\\n&quot;,ret); &#125; return 0;&#125; hdu2795(query:区间求最大值的位子(直接把update 的操作在query 里做了)) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 222222;int h , w , n;int MAX[maxn&lt;&lt;2];void PushUP(int rt) &#123; MAX[rt] = max(MAX[rt&lt;&lt;1] , MAX[rt&lt;&lt;1|1]);&#125;void build(int l,int r,int rt) &#123; MAX[rt] = w; if (l == r) return ; int m = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;int query(int x,int l,int r,int rt) &#123; if (l == r) &#123; MAX[rt] -= x; return l; &#125; int m = (l + r) &gt;&gt; 1; int ret = (MAX[rt&lt;&lt;1] &gt;= x) ? query(x , lson) : query(x , rson); PushUP(rt); return ret;&#125;int main() &#123; while (~scanf(&quot;%d%d%d&quot;,&amp;h,&amp;w,&amp;n)) &#123; if (h &gt; n) h = n; build(1 , h , 1); while (n --) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if (MAX[1] &lt; x) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;,query(x , 1 , h , 1)); &#125; &#125; return 0;&#125; 段更新需要用到延迟标记(或者说懒惰标记),简单来说就是每次更新的时候不要更新到底,用延迟标记使得更新延迟到下次需要更新or 询问到的时候 hdu1698（update:成段替换(由于只query 一次总区间,所以可以直接输出1 结点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 111111;int h , w , n;int col[maxn&lt;&lt;2];int sum[maxn&lt;&lt;2];void PushUp(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];&#125;void PushDown(int rt,int m) &#123; if (col[rt]) &#123; col[rt&lt;&lt;1] = col[rt&lt;&lt;1|1] = col[rt]; sum[rt&lt;&lt;1] = (m - (m &gt;&gt; 1)) * col[rt]; sum[rt&lt;&lt;1|1] = (m &gt;&gt; 1) * col[rt]; col[rt] = 0; &#125;&#125;void build(int l,int r,int rt) &#123; col[rt] = 0; sum[rt] = 1; if (l == r) return ; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; col[rt] = c; sum[rt] = c * (r - l + 1); return ; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (R &gt; m) update(L , R , c , rson); PushUp(rt);&#125;int main() &#123; int T , n , m; scanf(&quot;%d&quot;,&amp;T); for (int cas = 1 ; cas &lt;= T ; cas ++) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(1 , n , 1); while (m --) &#123; int a , b , c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); update(a , b , c , 1 , n , 1); &#125; printf(&quot;Case %d: The total value of the hook is %d.\\n&quot;,cas , sum[1]); &#125; return 0;&#125; poj3468(update:成段增减query:区间求和) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1#define LL long longconst int maxn = 111111;LL add[maxn&lt;&lt;2];LL sum[maxn&lt;&lt;2];void PushUp(int rt) &#123; sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];&#125;void PushDown(int rt,int m) &#123; if (add[rt]) &#123; add[rt&lt;&lt;1] += add[rt]; add[rt&lt;&lt;1|1] += add[rt]; sum[rt&lt;&lt;1] += add[rt] * (m - (m &gt;&gt; 1)); sum[rt&lt;&lt;1|1] += add[rt] * (m &gt;&gt; 1); add[rt] = 0; &#125;&#125;void build(int l,int r,int rt) &#123; add[rt] = 0; if (l == r) &#123; scanf(&quot;%lld&quot;,&amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; add[rt] += c; sum[rt] += (LL)c * (r - l + 1); return ; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (m &lt; R) update(L , R , c , rson); PushUp(rt);&#125;LL query(int L,int R,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; PushDown(rt , r - l + 1); int m = (l + r) &gt;&gt; 1; LL ret = 0; if (L &lt;= m) ret += query(L , R , lson); if (m &lt; R) ret += query(L , R , rson); return ret;&#125;int main() &#123; int N , Q; scanf(&quot;%d%d&quot;,&amp;N,&amp;Q); build(1 , N , 1); while (Q --) &#123; char op[2]; int a , b , c; scanf(&quot;%s&quot;,op); if (op[0] == &apos;Q&apos;) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%lld\\n&quot;,query(a , b , 1 , N , 1)); &#125; else &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); update(a , b , c , 1 , N , 1); &#125; &#125; return 0;&#125; 区间合并扫描线 hdu1542(矩形面积并) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 2222;int cnt[maxn &lt;&lt; 2];double sum[maxn &lt;&lt; 2];double X[maxn];struct Seg &#123; double h , l , r; int s; Seg()&#123;&#125; Seg(double a,double b,double c,int d) : l(a) , r(b) , h(c) , s(d) &#123;&#125; bool operator &lt; (const Seg &amp;cmp) const &#123; return h &lt; cmp.h;&#125;&#125;ss[maxn];void PushUp(int rt,int l,int r) &#123; if (cnt[rt]) sum[rt] = X[r+1] - X[l]; else if (l == r) sum[rt] = 0; else sum[rt] = sum[rt&lt;&lt;1] + sum[rt&lt;&lt;1|1];&#125;void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; cnt[rt] += c; PushUp(rt , l , r); return ; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (m &lt; R) update(L , R , c , rson); PushUp(rt , l , r);&#125;int Bin(double key,int n,double X[]) &#123; int l = 0 , r = n - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (X[m] == key) return m; if (X[m] &lt; key) l = m + 1; else r = m - 1; &#125; return -1;&#125;int main() &#123; int n , cas = 1; while (~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; int m = 0; while (n --) &#123; double a , b , c , d; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d); X[m] = a; ss[m++] = Seg(a , c , b , 1); X[m] = c; ss[m++] = Seg(a , c , d , -1); &#125; sort(X , X + m); sort(ss , ss + m); int k = 1; for (int i = 1 ; i &lt; m ; i ++) &#123; if (X[i] != X[i-1]) X[k++] = X[i]; &#125; memset(cnt , 0 , sizeof(cnt)); memset(sum , 0 , sizeof(sum)); double ret = 0; for (int i = 0 ; i &lt; m - 1 ; i ++) &#123; int l = Bin(ss[i].l , k , X); int r = Bin(ss[i].r , k , X) - 1; if (l &lt;= r) update(l , r , ss[i].s , 0 , k - 1, 1); ret += sum[1] * (ss[i+1].h - ss[i].h); &#125; printf(&quot;Test case #%d\\nTotal explored area: %.2lf\\n\\n&quot;,cas++ , ret); &#125; return 0;&#125; hdu1828思路:与面积不同的地方是还要记录竖的边有几个(numseg 记录),并且当边界重合的时候需要合并(用lbd 和rbd 表示边界来辅助)线段树操作:update:区间增减query:直接取根节点的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn = 22222;struct Seg&#123; int l , r , h , s; Seg() &#123;&#125; Seg(int a,int b,int c,int d):l(a) , r(b) , h(c) , s(d) &#123;&#125; bool operator &lt; (const Seg &amp;cmp) const &#123; if (h == cmp.h) return s &gt; cmp.s; return h &lt; cmp.h; &#125;&#125;ss[maxn];bool lbd[maxn&lt;&lt;2] , rbd[maxn&lt;&lt;2];int numseg[maxn&lt;&lt;2];int cnt[maxn&lt;&lt;2];int len[maxn&lt;&lt;2];void PushUP(int rt,int l,int r) &#123; if (cnt[rt]) &#123; lbd[rt] = rbd[rt] = 1; len[rt] = r - l + 1; numseg[rt] = 2; &#125; else if (l == r) &#123; len[rt] = numseg[rt] = lbd[rt] = rbd[rt] = 0; &#125; else &#123; lbd[rt] = lbd[rt&lt;&lt;1]; rbd[rt] = rbd[rt&lt;&lt;1|1]; len[rt] = len[rt&lt;&lt;1] + len[rt&lt;&lt;1|1]; numseg[rt] = numseg[rt&lt;&lt;1] + numseg[rt&lt;&lt;1|1]; if (lbd[rt&lt;&lt;1|1] &amp;&amp; rbd[rt&lt;&lt;1]) numseg[rt] -= 2;//两条线重合 &#125;&#125;void update(int L,int R,int c,int l,int r,int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; cnt[rt] += c; PushUP(rt , l , r); return ; &#125; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L , R , c , lson); if (m &lt; R) update(L , R , c , rson); PushUP(rt , l , r);&#125;int main() &#123; int n; while (~scanf(&quot;%d&quot;,&amp;n)) &#123; int m = 0; int lbd = 10000, rbd = -10000; for (int i = 0 ; i &lt; n ; i ++) &#123; int a , b , c , d; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); lbd = min(lbd , a); rbd = max(rbd , c); ss[m++] = Seg(a , c , b , 1); ss[m++] = Seg(a , c , d , -1); &#125; sort(ss , ss + m); int ret = 0 , last = 0; for (int i = 0 ; i &lt; m ; i ++) &#123; if (ss[i].l &lt; ss[i].r) update(ss[i].l , ss[i].r - 1 , ss[i].s , lbd , rbd - 1 , 1); ret += numseg[1] * (ss[i+1].h - ss[i].h); ret += abs(len[1] - last); last = len[1]; &#125; printf(&quot;%d\\n&quot;,ret); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"二分","slug":"二分","date":"2018-03-18T13:51:54.000Z","updated":"2018-03-18T14:11:45.936Z","comments":true,"path":"2018/03/18/二分/","link":"","permalink":"http://yoursite.com/2018/03/18/二分/","excerpt":"","text":"二分查找大家应该都知道二分查找，那直接从它的作用来说吧 从有序数组中查找某一个数12345678910111213141516int n,k;int a[maxn];void solve()&#123; //注意lb和ub int lb=-1,ub=n; while(ub-lb&gt;1)&#123; int mid=(lb+ub)/2; if(a[mid]&gt;=k)&#123; ub=mid; &#125;else&#123; lb=mid; &#125; &#125; //这时，lb+1=ub printf(&quot;%d\\n&quot;,ub);&#125; 判断一个解并判断是否可行我们可以在12345if(a[mid]&gt;=k)&#123; ub=mid; &#125;else&#123; lb=mid; &#125; 把a[mid]改成C(mid)判断是否可行。 最大化最小值最大化平均值","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"}]},{"title":"数论","slug":"数论","date":"2018-03-18T13:14:47.000Z","updated":"2018-03-18T13:44:39.310Z","comments":true,"path":"2018/03/18/数论/","link":"","permalink":"http://yoursite.com/2018/03/18/数论/","excerpt":"","text":"数论数论是一个比较大的话题，慢慢更 素数素数 母函数母函数 gcd123456789101112131415161718//欧几里得，又叫做最大公约数int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int gcd(int big, int small)&#123; if (small &gt; big) swap(big, small); int temp; while (small != 0)&#123; // 辗转相除法 if (small &gt; big) swap(big, small); temp = big % small; big = small; small = temp; &#125; return(big);&#125; 逆元12345678910111213141516171819202122//逆元gcd(a,b)=a*x+b*y;gcd(b,a%b,)ll extgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123; x=1,y=0; return a; &#125; ll d=extgcd(b,a%b,x,y); ll t=x; x=y; y=t-a/b*y; return d;&#125;ll inv(ll a,ll mod)&#123; ll x,y; extgcd(a,mod,x,y); return (mod+x%mod)%mod;&#125; 快速幂1234567891011ll fast_pow(ll a,ll b,ll mod)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;//快速幂 卡塔兰数123456789101112131415161718192021222324252627ll Catelan[N];//用逆元求解ll extgcd(ll a, ll b, ll&amp; x, ll&amp; y)&#123; ll d = a; if(b != 0)&#123; d = extgcd(b, a % b, y, x); y -= (a / b) * x; &#125;else &#123; x = 1; y = 0; &#125; return d;&#125;void pre()&#123; int i; ll x, y; Catelan[0] = 1, Catelan[1] = 1; for(i = 2; i &lt; N-5; i++) &#123; Catelan[i] = Catelan[i-1]*(4*i-2) % mod; extgcd(i+1, mod, x, y); Catelan[i] = (Catelan[i]*((x+mod)%mod)) % mod; &#125;&#125; 矩阵快速幂求逆元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100#define LL long long#define MOD 10000using namespace std;struct Matrix&#123; LL a[MAXN][MAXN]; int r, c;//行数 列数&#125;;Matrix ori, res;//初始矩阵 和 结果矩阵void init()//初始化矩阵&#123; memset(res.a, 0, sizeof(res.a)); res.r = 2; res.c = 2; for(int i = 1; i &lt;= 2; i++)//构造单位矩阵 res.a[i][i] = 1; ori.r = 2; ori.c = 2; ori.a[1][1] = ori.a[1][2] = ori.a[2][1] = 1; ori.a[2][2] = 0;&#125;Matrix multi(Matrix x, Matrix y)&#123; Matrix z; memset(z.a, 0, sizeof(z.a)); z.r = x.r, z.c = y.c;//新矩阵行数等于x矩阵的行数 列数等于y矩阵的列数 for(int i = 1; i &lt;= x.r; i++)//x矩阵的行数 &#123; for(int k = 1; k &lt;= x.c; k++)//矩阵x的列数等于矩阵y的行数 即x.c = y.r &#123; if(x.a[i][k] == 0) continue;//优化 for(int j = 1; j&lt;= y.c; j++)//y矩阵的列数 z.a[i][j] = (z.a[i][j] + (x.a[i][k] * y.a[k][j]) % MOD) % MOD; &#125; &#125; return z;&#125;void Matrix_mod(int n)&#123; while(n)//N次幂 &#123; if(n &amp; 1) res = multi(ori, res); ori = multi(ori, ori); n &gt;&gt;= 1; &#125; printf(&quot;%lld\\n&quot;, res.a[1][2] % MOD);&#125;int main()&#123; int N; while(scanf(&quot;%d&quot;, &amp;N), N!=-1) &#123; init();//初始化单位矩阵 Matrix_mod(N);//矩阵快速幂 &#125; return 0;&#125; 斯特灵近似1234ll steling(ll n)&#123; return ll(log10(sqrt(4*acos(0.0)*n))+n*log10(n/exp(1.0)))+1;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"胡思乱想","slug":"胡思乱想","date":"2018-03-18T11:22:26.000Z","updated":"2018-03-18T11:55:10.742Z","comments":true,"path":"2018/03/18/胡思乱想/","link":"","permalink":"http://yoursite.com/2018/03/18/胡思乱想/","excerpt":"","text":"果然，我还是喜欢胡思乱想。我想去工作，为什么？我认为自己需要社会学习的经历，需要挣钱，我想太多现在想要的东西，我想要更好的一切。一切都是钱哪，但是我又有一点遗憾，有一点失落。我想去读研，我希望自己可以活出自己想要的姿态，疯狂玩，疯狂学习，结交更多的人。我的性格说实话很奇怪，我不太喜欢说话，但是我经常有奇怪的想法想要和别人分享，我时时说不出口，我比较自卑，过分在意他人的看法和行动，我试图去改，改不掉。大学，是一个象牙塔，我还要呆在这里吗？读研，我认为比较迎合我自己的性格，同时现在是人工智能的时代，读一个好的研究生未来你会得到更好的发展机遇。我的大学，在我看来本科教育很失败。理论很水，项目基本没有，实验室老师也不通知说要同学来学习或者招人。导致我们学校本科生我认为科研没有，理论知识比较薄弱，代码能力太差。不知道是不是中国大学计算机教育的一个普遍问题。我认为自己喜欢难一点的东西，比如c++，比如linux下开发，比如算法和程序设计。不知道自己是喜欢装逼，喜欢获得优越感还是真的认为这个好。无所谓了，我就喜欢这些东西，中二就中二吧。我又认为自己很懒散，我自认为比较努力，但是我没有一个具体的目标，具体的方向。起床不要太晚，作业不要全部不会写，考试不要太差就好了。我认为这样有很大问题。自己就像没有方向的芦苇，来一阵风，就像风吹的方向摇摆，只要不要太差就好了。说了要改变，没有一次做到，每次都向自己妥协，妥协。","categories":[{"name":"Lifes","slug":"Lifes","permalink":"http://yoursite.com/categories/Lifes/"}],"tags":[]},{"title":"前序，中序，后序遍历","slug":"前序，中序，后序遍历","date":"2018-03-18T09:29:42.000Z","updated":"2018-03-18T09:29:50.868Z","comments":true,"path":"2018/03/18/前序，中序，后序遍历/","link":"","permalink":"http://yoursite.com/2018/03/18/前序，中序，后序遍历/","excerpt":"","text":"树的遍历我们知道树的遍历分为三种情况，前序，中序，后序，层序遍历我们现在要讨论的问题是得知前序和中序，求得后序和层序遍历或者得知后序和中序，求得前序和层序遍历 得知后序和中序，计算层序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=40;int hou[maxn];int mid[maxn];struct node&#123; int le; int ri;&#125;tree[maxn];int dfs(int ma,int mb,int ha,int hb)&#123; // if(ma==0||mb==0||ha==0||hb==0)return 0; if(ma&gt;mb)return 0; int root=hou[hb]; int p1=ma; int p2; while(mid[p1]!=root)p1++; p2=p1-ma; tree[root].le=dfs(ma,ma+p2-1,ha,ha+p2-1); tree[root].ri=dfs(p1+1,mb,ha+p2,hb-1); return root;&#125;void bfs(int root)&#123; queue&lt;int&gt;q; q.push(root); while(!q.empty())&#123; int cur=q.front(); q.pop(); if(cur!=root)cout&lt;&lt;&quot; &quot;; cout&lt;&lt;cur; int le,ri; le=tree[cur].le; ri=tree[cur].ri; if(le)q.push(le); if(ri)q.push(ri); &#125;&#125;int main ()&#123; int n; while(cin&gt;&gt;n)&#123; for(int i=0;i&lt;=n;i++)&#123; tree[i].le=0; tree[i].ri=0; &#125; for(int i=0;i&lt;n;i++)cin&gt;&gt;hou[i]; for(int i=0;i&lt;n;i++)cin&gt;&gt;mid[i]; int root=dfs(0,n-1,0,n-1); bfs(root); &#125; return 0;&#125; 得知前序和中序，求得层序和这个类似。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"树形遍历","slug":"树形遍历","permalink":"http://yoursite.com/tags/树形遍历/"}]},{"title":"回文串","slug":"回文串","date":"2018-03-18T09:17:01.000Z","updated":"2018-03-18T09:19:44.684Z","comments":true,"path":"2018/03/18/回文串/","link":"","permalink":"http://yoursite.com/2018/03/18/回文串/","excerpt":"","text":"回文串概念：什么是回文串“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。 实现： 循环中间节点，逐步向两边遍历 从两边向中间遍历。一次可以遍历两个，算法复杂度为nlogn 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;const int maxn=1000+10;int vis[maxn][maxn];string str;int p[maxn][maxn];int pa(int i,int j)&#123; if(i&gt;=j)return 1; if(str[i]!=str[j])return 0; if(vis[i][j])return p[i][j]; vis[i][j]=1; p[i][j]=pa(i+1,j-1); return p[i][j];&#125;int main()&#123; while(getline(cin,str))&#123; memset(vis,0,sizeof vis); int ans=0; int len=str.length(); for(int i=0;i&lt;len;i++)&#123; for(int j=i;j&lt;len;j++)&#123; if(pa(i,j))ans=max(ans,j-i+1); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"回文串","slug":"回文串","permalink":"http://yoursite.com/tags/回文串/"}]},{"title":"母函数","slug":"母函数","date":"2018-03-17T13:37:53.000Z","updated":"2018-03-17T14:53:14.661Z","comments":true,"path":"2018/03/17/母函数/","link":"","permalink":"http://yoursite.com/2018/03/17/母函数/","excerpt":"","text":"母函数什么是母函数 普通型母函数 对于如下等式：(1+a1x)(1+a2x)···(1+a3x)————————————————-（1）=1+(a1+a2+···+an)x+(a1a2+a1a3+···+an-1an)x^2+ ···+a1a2···anx^n–（2）通过式（1），我们得到式（2），这就是母函数，在应用中，一般知道（1），我们通过（1），计算出（2）的系数。 对于序列a0,a1,a2,···构造一个函数：G（x）=a0+a1x+a2X^2+···，称函数G(x)是序列a0,a1,a2,···的母函数。 母函数解决什么问题我们举几个例子： 若有1克，2克，3克，4克的砝码各一枚，能称出哪几种重量？各有几种可能方案？我们假设x的指数表示称出的重量，（1+x）表示一个1克砝码（1+x^2）表示一个2克砝码（1+x^3）表示一个3克砝码（1+x^4）表示一个4克砝码加上1的原因是可以选或者不选(1+x)(1+x2)(1+x3)(1+x4)=(1+x+x2+x3)(1+x3+x4+x7)=1+x+x2+2x3+2x4+2x5+2x6+2x7+x8+x9+x10于是我们知道称出5克砝码方案有2种，6克有2种，··· 求使用1分，2分，3分的邮票贴出不同数值的方案数由于允许重复，母函数为：G(x)=(1+x+x2+···)(1+x2+x4+···)(1+x3+x6+···) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//普通型母函数#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int c1[1000], c2[1000];int val[1000],a[1000];int main()&#123; int n,i, j, k; while(cin&gt;&gt;n) &#123; //这一段根据题意处理，主要处理每种的数量和这一种的价值 memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); for(i = 0; i &lt;=n; ++i)//初始化第一个多项式 &#123; c1[i]=1; &#125; for(i = 2; i &lt;=17; i++)//化简过程表示括号数量，从2开始，因为第一个括号不用操作 &#123; for(j = 0; j &lt;=n; j++)//判断左边 &#123; for(k = 0; j+ k&lt;=n; k+=val[i])//这个循环的限制条件根据题意而变，判断右边 &#123; c2[j + k] += c1[j]; &#125; &#125; for(j = 0; j &lt;=n; ++j) &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; printf(&quot;%d\\n&quot;,c1[n]); &#125; return 0;&#125;//指数型母函数#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100;double c1[N], c2[N],a[N];int val[N];void Factorial()&#123; a[0]=1; a[1]=1; for(int i = 2; i &lt;=20; i++) &#123; a[i]=a[i-1]*i; &#125;&#125;int main()&#123; int n, m, i, j, k; Factorial(); while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; for(i = 0; i &lt; n; ++ i) &#123; scanf(&quot;%d&quot;, &amp;val[i]); &#125; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); for(i = 0; i &lt;= val[0]; ++i) &#123; c1[i] = 1.0/a[i]; &#125; for(i = 1; i &lt; n; i++) &#123; for(j = 0; j &lt;= m; ++j) &#123; for(k = 0; k + j &lt;= m &amp;&amp; k &lt;= val[i]; ++k) &#123; c2[j + k] += c1[j]/a[k]; &#125; &#125; for(j = 0; j &lt;= m; ++j) &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; printf(&quot;%.0lf\\n&quot;, c1[m]*a[m]); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"母函数","slug":"母函数","permalink":"http://yoursite.com/tags/母函数/"}]},{"title":"素数筛法","slug":"素数筛法","date":"2018-03-17T13:17:46.000Z","updated":"2018-03-17T13:33:31.670Z","comments":true,"path":"2018/03/17/素数筛法/","link":"","permalink":"http://yoursite.com/2018/03/17/素数筛法/","excerpt":"","text":"素数 质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。 我们对于素数的判定的确经过了几个过程。我们一个一个来讨论 按照定义我们按照定义来实现找出素数1234567891011int flag=0;if(n&lt;2)flag=1;for(int i=2;i&lt;n;i++)&#123; if(n%i==0)&#123; flag=1; break; &#125;&#125;if(flag)cout&lt;&lt;&quot;不是素数&quot;&lt;&lt;endl;elsecout&lt;&lt;&quot;是素数&quot;&lt;&lt;endl; 通过定义来实现素数的判定。优点是比较好理解，缺点是时间复杂度比较高 埃拉托斯特尼筛法123456789101112memset(vis,0,sizeof(vis)); for(int i=2;i&lt;=n;i++) for(int j=i*2;j&lt;=n;j+=i) vis[j]=1;//优化int m=sqrt(n+0.5);memset(vis,0,sizeof(vis));for(int i=2;i&lt;=m;i++) if(!vis[i]) for(int j=i*i;j&lt;=n;j+=i) vis[j]=1; 这是一种求素数比较方便并且快速的方法。具体思想是筛去2，3，5，7等等的倍数，那么剩余的便是合数。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"素数","slug":"素数","permalink":"http://yoursite.com/tags/素数/"}]},{"title":"大数运算","slug":"大数运算","date":"2018-03-15T13:06:34.000Z","updated":"2018-03-16T15:51:03.109Z","comments":true,"path":"2018/03/15/大数运算/","link":"","permalink":"http://yoursite.com/2018/03/15/大数运算/","excerpt":"","text":"我们知道任何数值都有范围一说，c++肯定也一样int表示32为整数longlong表示64位整数数值过大就会存在溢出的情况怎么办？大数教你做人 大数加123456789101112131415161718192021222324252627282930313233string add(string a,string b)&#123; string c; int len1=a.length(); int len2=b.length(); int len=max(len1,len2); for(int i=len1;i&lt;len;i++) a=&quot;0&quot;+a; for(int i=len2;i&lt;len;i++) b=&quot;0&quot;+b; int ok=0; for(int i=len-1;i&gt;=0;i--) &#123; char temp=a[i]+b[i]-&apos;0&apos;+ok; if(temp&gt;&apos;9&apos;) &#123; ok=1; temp-=10; &#125; else ok=0; c=temp+c; &#125; if(ok) c=&quot;1&quot;+c; int pos=-1; for(int i=0;i&lt;c.length();i++)&#123; if(c[i]==&apos;0&apos;)pos=i; else break; &#125;// cout&lt;&lt;pos&lt;&lt;endl; if(pos==c.length()-1)return &quot;0&quot;; return c.substr(pos+1);&#125; 大数加法只是实现了简单的加减运算，记录每一位相加的结果（总的结果对10取余）以及进位（总的结果除以10） 大数减12345678910111213141516171819202122232425262728293031323334string sub(string a,string b)&#123; string c; bool ok=0; int len1=a.length(); int len2=b.length(); int len=max(len1,len2); for(int i=len1;i&lt;len;i++) a=&quot;0&quot;+a; for(int i=len2;i&lt;len;i++) b=&quot;0&quot;+b; if(a&lt;b) &#123; string temp=a; a=b; b=temp; ok=1; &#125; for(int i=len-1;i&gt;=0;i--) &#123; if(a[i]&lt;b[i]) &#123; a[i-1]-=1; a[i]+=10; &#125; char temp=a[i]-b[i]+&apos;0&apos;; c=temp+c; &#125; int pos=0; while(c[pos]==&apos;0&apos; &amp;&amp; pos&lt;len) pos++; if(pos==len) return &quot;0&quot;; if(ok) return &quot;-&quot;+c.substr(pos); return c.substr(pos);&#125; 大数加法和大数减法类似，如果对应位相减是负数，那么被减数的对应位数字前高一位减1，对应位加10。这是被减数减去减数就是存在的。 大数乘123456789101112131415161718192021string mul(string a,int b)&#123; string c; char s; int len=a.length(); int ok=0; for(int i=len-1;i&gt;=0;i--) &#123; int temp=(a[i]-&apos;0&apos;)*b+ok; ok=temp/10; s=temp%10+&apos;0&apos;; c=s+c; &#125; while(ok) &#123; s=ok%10+&apos;0&apos;; c=s+c; ok/=10; &#125; return c;&#125; 我们假设a*b类似于大数加法运算，a的每一位数字乘上b得到结果的当前位的初始值，当前位初始值对10取模得到结果的当前位。同时进位等于当前位初始值加上进位。我们假设12345*1212345678910 12* 12每一位的初始值等于12 24我们从右向左对十取模并且得到进位，将进位加到高一位的位置。那么有第一步：4（进位为2）第二步：12+2 4第三步：1 4 4结果就是144 大数除123456789101112131415161718string div(string a,int b)&#123; string c; int len=a.length(); int ans=0; char s; for(int i=0;i&lt;len;i++) &#123; ans=ans*10+a[i]-&apos;0&apos;; s=ans/b+&apos;0&apos;; ans%=b; c+=s; &#125; int pos=0; while(pos&lt;len &amp;&amp; c[pos]==&apos;0&apos;) pos++; if(pos==len) return &quot;0&quot;; return c.substr(pos);&#125; 这是模拟数式运算的一种实现方法。大家可以自己尝试一下。 总结 前导零 相加后的结果字长 字符串中存储的每一位的数字和我们已知的十进制表示法相反，也就是说高位在前，低位在后，而我们进行加减运算列等式的时候是低位对其进行计算，所以在计算前我们需要转换字符串的字符位置。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"大数","slug":"大数","permalink":"http://yoursite.com/tags/大数/"}]},{"title":"背包","slug":"背包","date":"2018-03-10T11:49:51.000Z","updated":"2018-03-17T13:19:07.919Z","comments":true,"path":"2018/03/10/背包/","link":"","permalink":"http://yoursite.com/2018/03/10/背包/","excerpt":"","text":"背包 背包简介问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。我们讨论三种背包方式。 01背包 完全背包 多重背包算法描述 01背包 有n个重量和价值分别为Wi，vi的物品，从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 我们设置状态转移方程dp[i][j]表示前i个物品在总重量小于等于j的情况下挑选的价值总和最大值。那么存在一个转移方程dp[i][j]=max(dp[i-1][j],dp[i-1][j-wi]+vi)如何理解呢？我们通过前i-1个物品推导出前i个物品的转移方程，如果我们取第i个物品，dp[i][j]=dp[i-1][j-wi]+vi如果我们不取第i个物品，dp[i][j]=dp[i-1][j]我们可以通过逆序来压缩掉一维空间dp[j]=max(dp[j],dp[j-wi]+vi)因为dp[j-wi]+vi此时保存的是dp[i-1][j-wi]+vi 完全背包 有n种重量和价值分别为wi，vi的物品。从这些物品中挑选总质量不超过W的物品，求出挑选物品质量价值总和的最大值。在这里，每种物品可以挑选任意多件。 其实01背包针对的问题是咱们每个物品只能挑选一次，而完全背包则是每个物品我们可以挑选任意多次。那么我们的状态状态转移方程可以写成：dp[i][j]=max(dp[i-1][j-k*wi]+k*vi)k大于等于0，且k*wi小于j我们可以将其优化为：dp[i][j]=max(dp[i][j],dp[i-1][j-wi]+vi)此时我们也可以降掉一维空间。使其满足``dp[j]=max(dp[j],dp[j-wi]+vi) 多重背包 有n种重量和价值分别为wi，vi的物品。从这些物品中挑选总质量不超过W的物品，求出挑选物品质量价值总和的最大值。在这里，每种物品最多可以挑选ni件。 其实这也是01背包的变形。dp[i][j]=max(dp[i-1][j-k*wi]+k*vi)0&lt;=k&lt;=ni，且k*wi小于j同时我们也可以通过二进制压缩来减小k的值。如果我们不进行压缩，我们需要遍历ni次如果我们进行压缩，那么我们需要遍历log(ni)次。二进制压缩的思想是将k分成2，4，8，16等等部分。假设k=10；我们分为2，4，4一共三份，(最后一份是10-2-4)那么此时2-》wi等同于2*wi，vi等同于2*vi4-》wi等同于4*wi，vi等同于4*vi4-》wi等同于4*wi，vi等同于4*vi每一个部分记录它的质量和体积，等同于多加了三个01背包的部分。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990c[i]表示体积w[i]表示重量//01背包for(int i=0;i&lt;N:i++)&#123; for(int j=V;j&gt;=c[i];j--) f[j]=max(f[j],f[j-c[i]]+w[i]);&#125;//完全背包for(int i=0;i&lt;N;i++)&#123; for(int j=c[i];j&lt;=V;j++) f[j]=max(f[j],f[j-c[i]]+w[i]);&#125;//多重背包for(int i=0;i&lt;N;i++)&#123; for(int k=1;k&lt;n[i];n[i]-=k,k&lt;&lt;=1) for(int j=V;j&gt;=k*c[i];j--) f[j]=max(f[j],f[j-k*c[i]]+k*w[i]); for(int j=V;j&gt;=n[i]*c[i];j--) f[j]=max(f[j],f[j-n[i]*c[i]]+n[i]*w[i]);&#125;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 101;const int SIZE = 50001;int dp[SIZE];int volume[MAXN], value[MAXN], c[MAXN];int n, v; // 总物品数，背包容量// 01背包void ZeroOnepark(int val, int vol)&#123; for (int j = v ; j &gt;= vol; j--) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;// 完全背包void Completepark(int val, int vol)&#123; for (int j = vol; j &lt;= v; j++) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;// 多重背包void Multiplepark(int val, int vol, int amount)&#123; if (vol * amount &gt;= v) &#123; Completepark(val, vol); &#125; else &#123; int k = 1; while (k &lt; amount) &#123; ZeroOnepark(k * val, k * vol); amount -= k; k &lt;&lt;= 1; &#125; if (amount &gt; 0) &#123; ZeroOnepark(amount * val, amount * vol); &#125; &#125;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; v) &#123; for (int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; c[i]; // 费用，价值，数量 &#125; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; Multiplepark(value[i], volume[i], c[i]); &#125; cout &lt;&lt; dp[v] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"}]},{"title":"考研规划","slug":"考研规划","date":"2018-03-08T11:30:23.000Z","updated":"2018-03-08T15:27:11.491Z","comments":true,"path":"2018/03/08/考研规划/","link":"","permalink":"http://yoursite.com/2018/03/08/考研规划/","excerpt":"","text":"高数： 阶段 复习教材以及习题 时间 基础巩固 数学教材（高数概率论线代）+张宇36讲 3-&gt;6月 基础巩固数学根据去年（2018年）大纲来复习书上的内容张宇36讲配套教材来吃透教材，形成知识链不要急，时间来得及 英语： 阶段 复习教材以及习题 时间 基础巩固 单词+阅读+语法 3-&gt;6月 基础巩固单词：恋练有词，希望可以过多边单词书阅读：我还是使用扇贝阅读，阅读需要配套翻译语法：刘晓艳长难句不要急，基础是重点，高楼平地起，没有基础，便没有提高","categories":[{"name":"Lifes","slug":"Lifes","permalink":"http://yoursite.com/categories/Lifes/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/tags/考研/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2018-03-07T16:04:36.000Z","updated":"2018-03-09T12:58:16.717Z","comments":true,"path":"2018/03/08/拓扑排序/","link":"","permalink":"http://yoursite.com/2018/03/08/拓扑排序/","excerpt":"","text":"拓扑排序算法简介 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边 uv,u 在排序中都在v之前。 例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径。也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。(转自维基百科) 算法描述我们一般存在两种算法实现方法 dfs 其实DFS就是深度优先搜索，它每次都沿着一条路径一直往下搜索，知道某个顶点没有了出度时，就停止递归，往回走，所以我们就用DFS的这个思路，我们可以得到一个有向无环图的拓扑序列，其实DFS很像Kahn算法的逆过程。 根据出入度（称之为Kahn算法） 在有向图中选一个没有前驱的顶点并且输出从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//使用dfsint n, G[maxn][maxn], c[maxn], topo[maxn], t;/* *n表示邻接表的个数， *c[]表示状态，为1表示访问过，为0表示未访问，为-1表示正在访问 *topo表示排完序的拓扑序列 */bool dfs(int u)&#123; c[u] = -1; for(int v = 0; v &lt; n; v++) if(G[u][v]) &#123; if(c[v]&lt;0) return false; //表示v也在被访问，说明u和v在一个环中，说明输入数据有问题，非DAG else if(!c[v]&amp;&amp;!dfs(v)) return false; //说明v没有被访问，但是以v为起始节点的时候，v存在环。 &#125; c[u] = 1; topo[--t]=u; //深搜到最后一个u的时候，topo[n-1]赋值为u return true;&#125;bool toposort()&#123; t = n; memset(c, 0, sizeof(c)); for(int u = 0; u &lt; n; u++) if(!c[u]) if(!dfs(u)) return false; return true;&#125;////////////////////////////////////////使用出度入度的思想int G[MAXN][MAXN];//路径int in_degree[MAXN];//入度int ans[MAXN];//路径int n;//顶点void toposort()&#123; for(i = 1; i &lt;= n; i++) &#123; for(j = 1; j &lt;= n; j++) &#123; if(G[i][j]) &#123; in_degree[j]++; &#125; &#125; &#125; for(i = 1; i &lt;= n; i++)//从最小的开始寻找， &#123;//这样保证了有多个答案时序号小的先输出 int k = 1; while(in_degree[k] != 0)//寻找入度为零的点 k++; ans[i] = k; in_degree[k] = -1; //更新为-1，后边检测不受影响，相当于删除节点 for(int j = 1; j &lt;= n; j++) &#123; if(G[k][j]) in_degree[j]--;//相关联的入度减1 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"最小生成树","slug":"最小生成树","date":"2018-03-07T16:03:34.000Z","updated":"2018-03-08T15:28:40.338Z","comments":true,"path":"2018/03/08/最小生成树/","link":"","permalink":"http://yoursite.com/2018/03/08/最小生成树/","excerpt":"","text":"最小生成树算法简介一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。简言之就是在一个连通图中找出一些边使得所有节点联通。 算法描述虽然有很多可以实现最小生成树的算法，我们只讨论Kruskal算法。 Kruskal（克鲁斯科尔算法）该算法算是贪心算法的引用 步骤： 新建图G，G中拥有原图中相同的节点，但没有边 将原图中所有的边按权值从小到大排序 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中 重复3，直至图G中所有的节点都在同一个连通分量中代码描述我们间接通过并查集来实现判断是否两个节点存在于同一个连通分量1234567891011121314151617181920212223242526272829303132333435int f[maxn];int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125;void join(int u,int v)&#123; int fu=find(u); int fv=find(v); if(fu!=fv)&#123; f[fu]=fv; &#125;&#125;struct edge&#123; int from,to,cost; friend bool operator &lt;(edge a,edge b)&#123; return a.cost&lt;b.cost; &#125;&#125;Ed[maxn];int V,E;int kruskal()&#123; sort(Ed,Ed+E); iniuni(V); int res=0; for(int i=0;i&lt;E;i++)&#123; edge e=Ed[i]; int fu=find(Ed[i].from); int fv=find(Ed[i].to); if(fu!=fv)&#123; join(e.from,e.to); res+=e.cost; &#125; &#125; return res;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"并查集","slug":"并查集","date":"2018-03-07T00:06:19.000Z","updated":"2018-03-07T00:32:19.880Z","comments":true,"path":"2018/03/07/并查集/","link":"","permalink":"http://yoursite.com/2018/03/07/并查集/","excerpt":"","text":"并查集概念简介在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。 为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。 算法描述用集合中的某个元素来代表这个集合，该元素称为集合的代表元。一个集合内的所有元素组织成以代表元为根的树形结构。在并查集算法中，合并操作是将该元素所在树连接在被合并元素所在树上。对于查找操作，即是路经查找到树根，确定代表元的过程。 判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。 优化存在两种优化算法： 按秩合并：使包含较少结点的树根指向包含较多结点的树根。 路径压缩：使路径查找上的每个点都直接指向根结点。路径压缩是一种在执行“查找”时扁平化树结构的方法。关键在于在路径上的每个节点都可以直接连接到根上；他们都有同样的表示方法。为了达到这样的效果，Find递归地经过树，改变每一个节点的引用到根节点。得到的树将更加扁平，为以后直接或者间接引用节点的操作加速。关键代码在find12345int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125; 完整代码描述 递归版本(存在溢出的情况) 12345678910111213int f[maxn];int find(int u)&#123; if(u==f[u])return u; f[u]=find(f[u]); return f[u];&#125;void join(int u,int v)&#123; int fu=find(u); int fv=find(v); if(fu!=fv)&#123; f[fu]=fv; &#125;&#125; 非递归版本 12345678910111213141516171819202122232425262728int pre[1000 ];void ini()//初始化，表示每个结点的父节点是其本身&#123; for(int i=0;i&lt;maxn;i++) pre[i]=i;&#125;int find(int x)//查找根节点&#123; int r=x; while ( pre[r] != r )//返回根节点 r r=pre[r]; int i=x,j; while(i!=r) //路径压缩 &#123; j = pre[i]; //在改变上级之前用临时变量 j 记录下他的值 pre[i]= r ; //把上级改为根节点 i=j; &#125; return r ;&#125;void join(int x,int y)//判断x y是否连通，//如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,&#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx]=fy;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"最短路算法","slug":"最短路算法","date":"2018-02-27T12:26:01.000Z","updated":"2018-03-01T07:38:12.145Z","comments":true,"path":"2018/02/27/最短路算法/","link":"","permalink":"http://yoursite.com/2018/02/27/最短路算法/","excerpt":"","text":"最短路算法松弛操作 松弛：v-&gt;w的距离可以通过p点来缩短，即dis（v,w）&lt;dis(v,p)+dis(p,w) Dijkstra算法（单源最短路）维基简介： 戴克斯特拉算法（英语：Dijkstra’s algorithm）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。迪科斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。 算法描述 这个算法是通过为每个顶点 v 保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点 s 的路径权重被赋为 0 （d[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 V 中的任意顶点 v， 若 v 不为 s 和上述 m 之一， d[v] = ∞）。当算法结束时，d[v] 中存储的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。 说人话！！！ 就是我们通过bfs遍历每一个点（通过边），当遍历到u点时，我们已知u点的邻边以及邻边的另一端的顶点v。我们通过u点来更新s到v的距离。代码描述就是：1234if(dis[v]&lt;dis[u]+edge(u,v))&#123; dis[v]=dis[u]+edge(u,v); //edge(u,v)表示u，v间边的距离。&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e4+10;const int INF=0x3f3f3f3f;struct edge&#123; int to,cost; edge(int to,int cost)&#123; this-&gt;to=to; this-&gt;cost=cost; &#125;&#125;;typedef pair&lt;int,int&gt;point;int dis[maxn];vector&lt;edge&gt;Ed[maxn];void addEdge(int u,int v,int value)&#123; Ed[u].push_back(edge(v,value));&#125;void Dijkstra(int s,int n)&#123; for(int i=0;i&lt;=n;i++)dis[i]=INF; dis[s]=0; priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q; q.push(point(dis[s],s)); while(!q.empty())&#123; point cur=q.top(); q.pop(); int v=cur.second; for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); &#125; &#125; &#125;&#125; spfa算法（单源最短路并且判负环）存在的原因我们在使用Dijstra算法时，如果出现负环，我们无法得出正确答案。我们来分析一下Dijstra算法的代码实现部分1234567for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); &#125;&#125; 我们运行一下如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn=1e4+10;const int INF=0x3f3f3f3f;struct edge&#123; int to,cost; edge(int to,int cost)&#123; this-&gt;to=to; this-&gt;cost=cost; &#125;&#125;;typedef pair&lt;int,int&gt;point;int dis[maxn];vector&lt;edge&gt;Ed[maxn];void addEdge(int u,int v,int value)&#123; Ed[u].push_back(edge(v,value));&#125;void Dijkstra(int s,int n)&#123; for(int i=0;i&lt;=n;i++)dis[i]=INF; dis[s]=0; priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt; &gt;q; q.push(point(dis[s],s)); cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;s&lt;&lt;&quot; 距离为&quot;&lt;&lt;dis[s]&lt;&lt;endl; while(!q.empty())&#123; point cur=q.top(); q.pop(); int v=cur.second; for(int i=0;i&lt;Ed[v].size();i++)&#123; edge e=Ed[v][i]; if(dis[e.to]&gt;dis[v]+e.cost)&#123; dis[e.to]=dis[v]+e.cost; q.push(point(dis[e.to],e.to)); cout&lt;&lt;&quot;节点号：&quot;&lt;&lt;e.to&lt;&lt;&quot; 距离为&quot;&lt;&lt;dis[e.to]&lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123; addEdge(0,1,2); addEdge(1,0,2); addEdge(0,2,1); addEdge(2,0,1); addEdge(1,2,-5); addEdge(2,1,-5); Dijkstra(0,3); return 0;&#125; 我们构造了一个负环，（0，1，2）（无向图）0号节点与1号节点相连，距离为20号节点与2号节点相连，距离为11号节点与2号节点相连，距离为-5运行结果如图：我们知道Dijkstra算法是通过不断更新相邻点的最小距离，由于存在负数，越更新，距离越小（负数越加越小），所以无法得出正确结论，甚至无法跳出循环。 算法描述其实和Dijkstra没有什么区别，只是加了判负环的操作。判负环的操作：我们一共有n个点，如果我们要得到最短路，不会有重复的路径。其次，对于一个点，与其相邻的最多有n-1个，即该点最多可以被更新n-1次。所以，我们只需要记录一个点入栈多少次，如果大于n-1，（或者n）则一定存在负权还。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 时间复杂度O(kE) * 队列实现，有时候改成栈实现会更快，较容易修改 */const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge&#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125;bool vis[MAXN]; // 在队列标志int cnt[MAXN]; // 每个点的入列队次数int dist[MAXN];bool SPFA(int start, int n)&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; while (!que.empty()) &#123; que.pop(); &#125; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) &#123; return false; // cnt[i]为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; &#125; return true;&#125; Floyd-Warshall算法（多源最短路）维基简介 Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N^3)，空间复杂度为O(N2)。 算法描述Floyd-Warshall算法的原理是动态规划我们假设只使用顶点0~k和i，j的情况下，记录i到j的最短路长度为d[k+1][i][j]所以d[0][i][j]表示不使用中间节点是i到j的距离，那么直接等于cost[i][j]我们分成两种情况： 不经过顶点kd[k][i][j]=d[k-1][i][j]; 经过顶点kd[k][i][j]=d[k-1][i][k]+d[k-1][k][j]; 所以，我们可以得知d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]);同时，我们可以去掉一维数组d[i][j]=min(d[i][k],d[k][j]) 代码实现1234567891011121314151617181920212223242526272829303132/* * Floyd算法，求从任意节点i到任意节点j的最短路径 * cost[][]:初始化为INF（cost[i][i]：初始化为0） * lowcost[][]:最短路径，path[][]:最短路径（无限制） */const int MAXN = 100;int cost[MAXN][MAXN];int lowcost[MAXN][MAXN];int path[MAXN][MAXN];void Floyd(int n)&#123; memcpy(lowcost, cost, sizeof(cost)); memset(path, -1, sizeof(path)); for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (lowcost[i][j] &gt; (lowcost[i][k] + lowcost[k][j])) &#123; lowcost[i][j] = lowcost[i][k] + lowcost[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125; return ;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"}]},{"title":"3月计划","slug":"3月计划","date":"2018-02-26T15:27:43.000Z","updated":"2018-02-26T15:42:11.640Z","comments":true,"path":"2018/02/26/3月计划/","link":"","permalink":"http://yoursite.com/2018/02/26/3月计划/","excerpt":"","text":"需要准备的事情： 蓝桥杯时间是2018年4月1日星期天 天梯赛时间是2018年3月31日13:00——16:00 考研安排 刷团队设计天梯赛往年的题目（认真刷level2的题目，lever3的题目写不来，level2的题目可以争取一下） 重新刷一遍杭电2000到2100的题目，并加以总结 刷一遍历届试题（重点刷这个） 算法归纳总结： 搜索 dfs bfs 枚举 贪心 贪心 动态规划 简单DP（找规律） 背包 树形DP 数位DP 数据结构 二叉树相关 优先队列相关 并查集 线段树 图论 最短路算法 最小生成树 拓扑排序 数论 gcd 扩展gcd 素数相关 逆元 斯特林近似 快速幂 矩阵快速幂 卡塔兰数 一元线性同余方程 字符串 kmp 字符串距离 代数几何 凸包 判断三点方向 多边形面积 最小点对 四点共面 多边形重心 奇技淫巧 二分查找 尺取法 随机化算法 大数算法（蓝桥杯报了c++组，坑呀） 加 减 乘 博弈 简单博弈（三种）","categories":[{"name":"Lifes","slug":"Lifes","permalink":"http://yoursite.com/categories/Lifes/"}],"tags":[{"name":"计划","slug":"计划","permalink":"http://yoursite.com/tags/计划/"}]},{"title":"c++继承之虚继承","slug":"c-继承之虚继承","date":"2018-02-26T12:43:12.000Z","updated":"2018-02-26T12:59:23.020Z","comments":true,"path":"2018/02/26/c-继承之虚继承/","link":"","permalink":"http://yoursite.com/2018/02/26/c-继承之虚继承/","excerpt":"","text":"虚继承存在的理由 存在即合理 虽然我们相信这句话，但是为什么合理呢？是什么促使它存在的呢？我们引出一个概念，菱形继承什么是菱形继承：1234567891011121314151617181920class A //大小为4&#123;public: int a;&#125;;class B : public A&#123;public: int b;&#125;;class C : public A&#123;public: int c;&#125;;class D :public B, public C&#123;public: int d;&#125;; 我们画出它的类图，会发现是一个菱形当我们实例化D类,对象是d，并且调用d.a;那么会出现二义性的问题。通过引入虚函数，可以解决以下问题： 二义性问题 浪费存储空间 实现原理 每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间） 虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了 当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 我的理解是通过偏移地址，找到虚基类成员，如果两个父类的父类是一个类，类似于B的父类是A，C的父类是A，B，C父类相同，那么我们不需要两份相同的继承。 代码示例1234567891011121314151617181920class A&#123;public: int a;&#125;;class B :virtual public A&#123;public: int b;&#125;;class C :virtual public A&#123;public: int c;&#125;;class D :public B, public C&#123;public: int d;&#125;; 注意virtual的位置。","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之多重继承和多继承","slug":"c-继承之多重继承和多继承","date":"2018-02-25T08:18:04.000Z","updated":"2018-02-25T08:36:39.299Z","comments":true,"path":"2018/02/25/c-继承之多重继承和多继承/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之多重继承和多继承/","excerpt":"","text":"多重继承概念多重继承是一个类的父类也有父类。多重继承的对象初始化方式最高的父类到子类。A()–&gt;B–&gt;C()销毁时正好是初始化的反顺序。~C–&gt;~B–&gt;A()代码示例为：123class A&#123;&#125;;class B:public A&#123;&#125;;class C:public B&#123;&#125;; 特点： 多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承 当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。 无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。 多继承概念多继承是一个类有2个以上父类。多继承的对象初始化方式是父类依次初始化。A()–&gt;B–&gt;AB()销毁时正好是初始化的反顺序。~AB–&gt;~B()–&gt;A~() 代码示例123class A&#123;&#125;;class B&#123;&#125;;class AB:public A,public B&#123;&#125;;","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之is_a和has_a","slug":"c-继承之is-a和hasas-a","date":"2018-02-25T08:17:34.000Z","updated":"2018-02-25T08:36:53.319Z","comments":true,"path":"2018/02/25/c-继承之is-a和hasas-a/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之is-a和hasas-a/","excerpt":"","text":"is_a原则概念举一个例子，有一个Horse类可以保存关于马的所有信息，身高体重等等，那么我们就可以从Horse类中派生出白马类，白马类包含所有Horse类的成员，在白马类中可以新增关于白马的成员，这个成员通常不用于Horse类。1234567891011class Horse&#123;public: int Tall; int Weight;&#125;;class WhiteHorse:public Horse&#123;public: int Color;&#125;; 上面的代码中，WhiteHorse多了颜色这个成员。整体来看，is-a表示了一种是的关系。比如白马是马，香蕉是水果，老师是人这种关系。并且public的继承方式建立了is_a的关系。 使用实例派生类Soldier继承自基类Person123456789101112131415161718192021222324//Person.hclass Person&#123;public: Person(string name = &quot;Jim&quot;); ~Person(); void play();protected: string m_strName;&#125;;//Soldier.hclass Soldier : public Person&#123;public: Soldier(string name = &quot;James&quot;, int age = 20); ~Soldier(); void work();protected: int m_iAge;&#125;; 派生类可以给基类赋值：1234567//main.cppint main()&#123; Soldier s1; Person p1 = s1; return 0;&#125; 因为一个士兵也是一个人。 基类指针可以指向派生类(派生类可以取地址给基类)：1234567//main.cppint main()&#123; Soldier s1; Person *p2 = &amp;s1; return 0;&#125; 同理，一个士兵也是一个人，父类的指针也可以指向子类对象。 把基类的指针或者是基类的对象或者是基类的引用作为函数的参数来使它可以接收所传入的子类的对象，并且也可以传入基类的对象 1234567891011121314151617void func1(Person *p)&#123; ......&#125;void func2(Person &amp;p)&#123; ......&#125;//main.cppint main()&#123; Person p1; Soldier s1; func1(&amp;p1); func2(p1); func1(&amp;s1); func2(s1); return 0;&#125; 基类只能接收和访问派生类中自己有的数据成员和成员函数 123456789101112131415//#include &quot;Person.h&quot;# include &quot;Soldier.h&quot;int main() &#123; Soldier soldier; Person person; person = soldier; person.play(); Person *p = &amp;soldier; p-&gt;play(); // 使用基类声明的对象只能调用基类的方法 //p-&gt;work(); // 使用基类声明的对象不能调用派生类的方法 return 0;&#125; 如果需要调用子类的成员函数，那么就是多态的内容了，后面再说。这是在编译期就决定了的。 通过基类的指针指向派生类的对象123456789101112131415//#include &quot;Person.h&quot;#include &quot;Soldier.h&quot;int main() &#123; Person *pp = new Soldier; // 基类的指针去指向派生类的内存空间 pp-&gt;play(); delete pp; // 销毁基类的对象，执行的是基类的析构函数，派生类的内存并没有释放 pp = NULL; return 0;&#125;LOG:Person::play()JamesPerson::~Person() has_a原则概念&emsp;&emsp;has-a体现了有这个思想。&emsp;&emsp;比如，午餐有香蕉。但是午餐不是香蕉。&emsp;&emsp;其实私有跟保护继承体现了has-a原则是因为，私有跟保护继承是实现继承。&emsp;&emsp;什么是实现继承呢？&emsp;&emsp;实现继承的主要目标是代码重用，我们发现类B和类C存在同样的代码，因此我们设计了一个类 A，用于存放通用的代码，基于这种思路的继承称为实现继承。&emsp;&emsp;我们可以说，午餐中存在香蕉。&emsp;&emsp;而共有继承则不是，为什么？ 在需要基类对象的任何地方都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。那么就可得到，当为私有或保护继承的时候，是包含的关系，基类在派生类中是私有的。需要基类的时候是不能用派生类代替的。 两种情况 包含 12345678class Banana&#123;..&#125;;class Lauch&#123; private: class Banana; ......&#125;; 私有继承c++还有另一种实现has-a关系的途径—-私有继承。 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。 使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口，这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法。简而言之，派生类不能继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。 因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所以，私有继承也可以用来实现has-a关系。 使用包含还是私有继承 &emsp;&emsp;大多数c++程序员倾向于前者。不过私有继承所提供的特性确实比包含多。例如，假设类包含保护成员，则这样的成员在派生类中是可用的，但在继承层次机构外是不可用的。如果使用组合奖这样的类保护在另一类中，则后者将不是排成类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承的到的将是派生类，因此他能够访问保护成员。 另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承之隐藏","slug":"c-继承之隐藏","date":"2018-02-25T08:16:53.000Z","updated":"2018-02-25T08:36:50.804Z","comments":true,"path":"2018/02/25/c-继承之隐藏/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承之隐藏/","excerpt":"","text":"隐藏概念：隐藏是指派生类的函数屏蔽了与其同名的基类函数。 代码实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()&#123; cout&lt;&lt;&quot;Person的构造函数&quot;&lt;&lt;endl; &#125; ~Person()&#123; cout&lt;&lt;&quot;Person的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Person的eat函数&quot;&lt;&lt;endl; &#125;private: int m_iAge; string m_strName;&#125;;class Worker :public Person&#123;public: Worker()&#123; cout&lt;&lt;&quot;Worker的构造函数&quot;&lt;&lt;endl; &#125; ~Worker()&#123; cout&lt;&lt;&quot;Worker的析构函数&quot;&lt;&lt;endl; &#125; void eat()&#123; cout&lt;&lt;&quot;Worker的eat函数&quot;&lt;&lt;endl; &#125; void work()&#123; cout&lt;&lt;&quot;Worker的work函数&quot;&lt;&lt;endl; &#125;private: int m_iSalary;&#125;;int main()&#123; Worker w; w.eat(); w.Person::eat(); return 0;&#125; 运行结果为：12345678910Person的构造函数Worker的构造函数Worker的eat函数Person的eat函数Worker的析构函数Person的析构函数--------------------------------Process exited after 0.1206 seconds with return value 0请按任意键继续. . . 简易解释 Worker是子类，Person是父类，我们在栈上实例化子类方法，首先调用父类构造函数，其次调用子类构造函数。析构函数则反之，并且栈上的空间是由系统管理，系统调用析构函数。 父类中的eat()函数被隐藏，w.eat()调用的是子类的eat()函数。 如果我们需要调用父类的成员函数，可以采用w.Person::eat();的方法。 几个易混淆的名词 隐藏：不解释了 覆盖或者称之为重写（override）如果我们没有在子类中定义同名的虚函数，那么在子类虚函数表当中就会写上父类当中那个虚函数的函数入口地址，如果我们在子类中也定义了同名的虚函数，那么在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。 如何记忆隐藏并没有消失，可以通过特殊的手段访问，数据成员也有隐藏这种现象。而覆盖则是在子类的虚函数表当中，我们就会把原来父类的虚函数的函数地址覆盖一下，覆盖成子类的虚函数的函数地址。（后续会有博客详细解释）","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"c++继承方式","slug":"c-继承方式","date":"2018-02-25T07:36:58.000Z","updated":"2018-02-25T08:36:45.566Z","comments":true,"path":"2018/02/25/c-继承方式/","link":"","permalink":"http://yoursite.com/2018/02/25/c-继承方式/","excerpt":"","text":"c++继承（三种继承方式）三种继承方式 共有继承公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 私有继承私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 保护继承保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。继承方式之间的关系 继承方式 基类的public成员 基类的protected成员 基类的private成员 public 成为public成员 成为protected成员 不可见 protected 成为protected成员 成为protected成员 不可见 private 成为private成员 成为private成员 不可见 注意事项 不管是哪种继承方式， 在派生类内部都可以访问基类的公有成员和保护成员 ， 基类的私有成员存在但是在子类中不可见（ 不能访问） 。 使用关键字class时默认的继承方式是private， 使用struct时默认的继承方式是public， 不过最好显式的写出继承方式。 在实际运用中一般使用都是public继承， 极少场景下才会使用protetced/private继承。 在struct继承中，如果没有显式给出继承类型，则默认的为public继承；在class继承中，如果没有显式给出继承类型，则默认的为private继承；简单总结三种类成员访问限定符 public（共有） protected（保护） private（私有）三种继承关系 public（共有继承） protected（保护继承） private(私有继承)","categories":[{"name":"Languages","slug":"Languages","permalink":"http://yoursite.com/categories/Languages/"},{"name":"c++","slug":"Languages/c","permalink":"http://yoursite.com/categories/Languages/c/"}],"tags":[{"name":"c++继承","slug":"c-继承","permalink":"http://yoursite.com/tags/c-继承/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-08T08:49:36.568Z","updated":"2018-02-25T08:09:44.759Z","comments":true,"path":"2018/02/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Clean cache1$ hexo clean Generate static files1$ hexo generate More info: Generating Compress code using gulp1$ gulp More info: Gulp Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}